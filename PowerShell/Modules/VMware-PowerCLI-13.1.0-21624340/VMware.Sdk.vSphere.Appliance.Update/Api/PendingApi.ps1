#
# Update Paths
# The appliance update package provides services for updating the software in the appliance. The package is available starting in vSphere 6.5.
# Contact: powercli@vmware.com
# Generated by OpenAPI Generator: https://openapi-generator.tech
#

<#
.SYNOPSIS

Gets update information

.DESCRIPTION

No description available.

.PARAMETER Version
Update version The parameter must be an identifier for the resource type: com.vmware.appliance.update.pending.

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

UpdatePendingInfo

.LINK

Online Version: https://developer.vmware.com/docs/vsphere-automation/latest/appliance/api/appliance/update/pending/version/get/
#>
function Invoke-GetVersionUpdatePending {
    [CmdletBinding(
        SupportsShouldProcess = $true,
        ConfirmImpact = 'None',
        HelpURI = "https://developer.vmware.com/docs/vsphere-automation/latest/appliance/api/appliance/update/pending/version/get/"
    )]
    Param (
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ValidateScript({ $_ -is [string] })]
        ${Version},
        [Parameter()]
        [vSphereConnectionToServerConfigurationArgumentTransformationAttribute()]
        [PSTypeName('vSphereServerConfiguration')]
        $Server,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Invoke-GetVersionUpdatePending' | Write-Debug

        $ServerConfigurations = Get-vSphereServerConfiguration
        if ($PSBoundParameters.ContainsKey('Server')) {
            $ServerConfigurations = $Server
        }

        if ($null -eq $ServerConfigurations) {
            throw "You are not currently connected to any servers. Please connect first using a Connect-VIServer cmdlet or add vSphere Server Configuration with New-vSphereServerConfiguration."
        }

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $ServerFromInputParameters = $null
        $InputParametersFromServer = $PSBoundParameters.Values | Where-Object -FilterScript { $_.PSObject.TypeNames -Contains 'ServerObject' }

        foreach ($InputParameterFromServer in $InputParametersFromServer) {
            $InputParameterServer = $InputParameterFromServer.GetServer()
            if (
                !$PSBoundParameters.ContainsKey('Server') -and
                $null -ne $ServerFromInputParameters -and
                !$ServerFromInputParameters.Equals($InputParameterServer)
            ) {
                $ErrorMessage = "{0} and {1} come from different servers. {0} from {2} and {1} from {3}. Please specify the -Server parameter of the cmdlet."
                throw ($ErrorMessage -f $ServerFromInputParameters.InputParameter, $InputParameterFromServer, $ServerFromInputParameters.Server, $InputParameterServer)
            }

            if ($null -eq $ServerFromInputParameters) {
                $ServerFromInputParameters = [PSCustomObject] @{
                    InputParameter = $InputParameterFromServer
                    Server = $InputParameterServer
                }
            }
        }

        if (
            $null -ne $ServerFromInputParameters -and
            $PSBoundParameters.ContainsKey('Server') -and
            !$ServerFromInputParameters.Server.Equals($Server)
        ) {
            $ErrorMessage = "{0} comes from server {1} but server {2} is explicitly specified."
            throw ($ErrorMessage -f $ServerFromInputParameters.InputParameter, $ServerFromInputParameters.Server, $Server)
        }

        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json')


        $serversToProcess = $ServerConfigurations

        if (!$PSBoundParameters.ContainsKey('Server') -and $null -ne $ServerFromInputParameters) {
            $serversToProcess = $ServerFromInputParameters.Server
        }

        foreach ($serverConfiguration in $serversToProcess) {
            $shouldProcessActionMessage = "Performing the operation 'GetVersionUpdatePending' on target server '$($serverConfiguration.ToString())'."
            $shouldProcessActionCaption = 'Are you sure you want to perform this action?'

            if ($PSCmdlet.ShouldProcess(
                    $shouldProcessActionMessage,
                    $shouldProcessActionMessage,
                    $shouldProcessActionCaption
                )
            ) {
                $LocalVarUri = '/api/appliance/update/pending/{version}'
                $LocalVarMethod = 'GET'

                $useDeprecatedApis = ($null -ne $serverConfiguration.UseDeprecatedApis -and $serverConfiguration.UseDeprecatedApis)
                $translationSchema = $null
                $transformedOpertaionInput = New-InputTransformationStructure
                if ($useDeprecatedApis) {
                    # Use Deprecated APIs
                    $translationSchema = Get-OperationTranslationSchema `
                        -operationPath $LocalVarUri.Replace('__', '?') `
                        -operationVerb $LocalVarMethod
                    if ($null -ne $translationSchema) {
                        $LocalVarUri = $translationSchema.OldPath
                        $LocalVarMethod = $translationSchema.OldVerb
                    }
                }

                if (!$Version) {
                    throw "Error! The required parameter `Version` missing when calling getVersionUpdatePending."
                }
                $LocalVarUri = $LocalVarUri.replace('{version}', $Version)
                $LocalVarPathParameters['version'] = $Version
                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    $addTransformationInput = Format-PathParams -OperationTranslateSchema $translationSchema -PathParams $LocalVarPathParameters
                    Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                }
                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    $addTransformationInput = Format-Headers -OperationTranslateSchema $translationSchema -Headers $LocalVarHeaderParameters
                    Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                }
                if (
                    $useDeprecatedApis -and
                    ($null -ne $translationSchema) -and
                    ($LocalVarQueryParameters.Count -gt 0)
                ) {
                    $inputQuerySctructure = [PSCustomObject]$LocalVarQueryParameters
                    $translatedBody = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $inputQuerySctructure -InputType Body
                    $translatedQuery = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $inputQuerySctructure -InputType Query

                    if ($null -ne $translatedBody) {
                        $LocalVarBodyParameter = $translatedBody | ConvertTo-Json -Depth 100

                        if ($LocalVarContentTypes.Count -eq 0) {
                            $LocalVarContentTypes = @('application/json')
                        }
                    }
                    $LocalVarQueryParameters = @{}
                    $translatedQuery.PSObject.Properties | Foreach-Object { $LocalVarQueryParameters[$_.Name] = $_.Value }
                }

                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    if ($null -ne $transformedOpertaionInput.Path) {
                        foreach ($keyValue in $transformedOpertaionInput.Path.GetEnumerator()) {
                            $LocalVarUri = $LocalVarUri.replace("{$($keyValue.Key)}", $keyValue.Value)
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Query) {
                        foreach ($keyValue in $transformedOpertaionInput.Query.GetEnumerator()) {
                            $LocalVarQueryParameters[$($keyValue.Key)] = $keyValue.Value
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Header) {
                        foreach ($keyValue in $transformedOpertaionInput.Header.GetEnumerator()) {
                            $LocalVarHeaderParameters[$($keyValue.Key)] = $keyValue.Value
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Body) {
                         $LocalVarBodyParameter = $transformedOpertaionInput.Body | ConvertTo-Json -Depth 100
                    }
                }

                $invokeParams = @{
                    'Method' = $LocalVarMethod
                    'Uri' = $LocalVarUri
                    'Accepts' = $LocalVarAccepts
                    'ContentTypes' = $LocalVarContentTypes
                    'Body' = $LocalVarBodyParameter
                    'HeaderParameters' = $LocalVarHeaderParameters
                    'QueryParameters' = $LocalVarQueryParameters
                    'FormParameters' = $LocalVarFormParameters
                    'CookieParameters' = $LocalVarCookieParameters
                    'ReturnType' = "UpdatePendingInfo"
                    'IsBodyNullable' = $false
                    'Server' = $serverConfiguration
                }

                if ($PSBoundParameters.ContainsKey('Debug')) {
                    $invokeParams['Debug'] = $Debug
                }

                if ($PSBoundParameters.ContainsKey('Verbose')) {
                    $invokeParams['Verbose'] = $Verbose
                }

                if ($PSBoundParameters.ContainsKey('WarningAction')) {
                    $invokeParams['WarningAction'] = $PSBoundParameters.WarningAction
                }

                if ($PSBoundParameters.ContainsKey('ErrorAction')) {
                    $invokeParams['ErrorAction'] = $PSBoundParameters.ErrorAction
                }

                $invokeParams['InvocationInfo'] = @{
                    'ModuleName' = $MyInvocation.MyCommand.ModuleName
                    'CmdletName' = $MyInvocation.MyCommand.Name
                }

                $invokeResult = Invoke-vSphereApiClient @invokeParams

                $invokeResult | Foreach-Object {
                    $SingleServerResult = $_
                    if ($SingleServerResult -is [hashtable]) {

                        if ($useDeprecatedApis -and ($null -ne $translationSchema) -and ($null -ne $SingleServerResult["Response"])) {
                            $ServerName = $SingleServerResult["Response"].PSObject.TypeNames | Where-Object -FilterScript { $_.StartsWith('Server:') }

                            $SingleServerResult["Response"] = Convert-OutputBody `
                                -OperationTranslateSchema $translationSchema `
                                -OperationOutputObject $SingleServerResult["Response"]

                            if (![string]::IsNullOrEmpty($ServerName)) {
                                $SingleServerResult["Response"] | ForEach-Object -Process {
                                    $_.PSObject.TypeNames.Add($ServerName)

                                    $_ = $_ | Add-Member -MemberType ScriptMethod -Name GetServer -Value {
                                        $productServerString = ($this.PSObject.TypeNames | Where-Object -FilterScript { $_.StartsWith('Server:') }).Substring(7)
                                        $productSeparatorIndex = $productServerString.IndexOf(':')

                                        $product = $productServerString.Substring(0, $productSeparatorIndex)
                                        $server = $productServerString.Substring($productSeparatorIndex + 1, $productServerString.Length - $productSeparatorIndex - 1)

                                        Get-ServerConfiguration -Product $product | Where-Object -FilterScript { $_.ToString() -eq $server }
                                    } -Force -PassThru

                                    $_.PSObject.TypeNames.Add("ServerObject")
                                }
                            }
                        }

                        $SingleServerResult["Response"].PSObject.TypeNames.Insert(0, "UpdatePendingInfo")

                        if ($WithHttpInfo.IsPresent) {
                            # result object
                            $SingleServerResult
                        } else {
                            # result object
                            $SingleServerResult["Response"]
                        }

                    } else {
                        Write-Warning "An item from the Invoke-vSphereApiClient was expected to be a Hashtable but it is '$($SingleServerResult.GetType())'"
                    }
                }
            }
        }
    }
}

<#
.SYNOPSIS

Starts operation of installing the appliance update. Will fail is the update is not staged

.DESCRIPTION

No description available.

.PARAMETER Version
Update version The parameter must be an identifier for the resource type: com.vmware.appliance.update.pending.

.PARAMETER UpdatePendingInstallRequestBody
No description available.

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

None

.LINK

Online Version: https://developer.vmware.com/docs/vsphere-automation/latest/appliance/api/appliance/update/pending/versionactioninstall/post/
#>
function Invoke-InstallVersionPending {
    [CmdletBinding(
        SupportsShouldProcess = $true,
        ConfirmImpact = 'Low',
        HelpURI = "https://developer.vmware.com/docs/vsphere-automation/latest/appliance/api/appliance/update/pending/versionactioninstall/post/"
    )]
    Param (
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ValidateScript({ $_ -is [string] })]
        ${Version},
        [Parameter(Mandatory = $true)]
        [PSTypeName("UpdatePendingInstallRequestBody")]
        [PSCustomObject]
        ${UpdatePendingInstallRequestBody},
        [Parameter()]
        [vSphereConnectionToServerConfigurationArgumentTransformationAttribute()]
        [PSTypeName('vSphereServerConfiguration')]
        $Server,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Invoke-InstallVersionPending' | Write-Debug

        $ServerConfigurations = Get-vSphereServerConfiguration
        if ($PSBoundParameters.ContainsKey('Server')) {
            $ServerConfigurations = $Server
        }

        if ($null -eq $ServerConfigurations) {
            throw "You are not currently connected to any servers. Please connect first using a Connect-VIServer cmdlet or add vSphere Server Configuration with New-vSphereServerConfiguration."
        }

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $ServerFromInputParameters = $null
        $InputParametersFromServer = $PSBoundParameters.Values | Where-Object -FilterScript { $_.PSObject.TypeNames -Contains 'ServerObject' }

        foreach ($InputParameterFromServer in $InputParametersFromServer) {
            $InputParameterServer = $InputParameterFromServer.GetServer()
            if (
                !$PSBoundParameters.ContainsKey('Server') -and
                $null -ne $ServerFromInputParameters -and
                !$ServerFromInputParameters.Equals($InputParameterServer)
            ) {
                $ErrorMessage = "{0} and {1} come from different servers. {0} from {2} and {1} from {3}. Please specify the -Server parameter of the cmdlet."
                throw ($ErrorMessage -f $ServerFromInputParameters.InputParameter, $InputParameterFromServer, $ServerFromInputParameters.Server, $InputParameterServer)
            }

            if ($null -eq $ServerFromInputParameters) {
                $ServerFromInputParameters = [PSCustomObject] @{
                    InputParameter = $InputParameterFromServer
                    Server = $InputParameterServer
                }
            }
        }

        if (
            $null -ne $ServerFromInputParameters -and
            $PSBoundParameters.ContainsKey('Server') -and
            !$ServerFromInputParameters.Server.Equals($Server)
        ) {
            $ErrorMessage = "{0} comes from server {1} but server {2} is explicitly specified."
            throw ($ErrorMessage -f $ServerFromInputParameters.InputParameter, $ServerFromInputParameters.Server, $Server)
        }

        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json')

        # HTTP header 'Content-Type'
        $LocalVarContentTypes = @('application/json')


        $serversToProcess = $ServerConfigurations

        if (!$PSBoundParameters.ContainsKey('Server') -and $null -ne $ServerFromInputParameters) {
            $serversToProcess = $ServerFromInputParameters.Server
        }

        foreach ($serverConfiguration in $serversToProcess) {
            $shouldProcessActionMessage = "Performing the operation 'InstallVersionPending' on target server '$($serverConfiguration.ToString())'."
            $shouldProcessActionCaption = 'Are you sure you want to perform this action?'

            if ($PSCmdlet.ShouldProcess(
                    $shouldProcessActionMessage,
                    $shouldProcessActionMessage,
                    $shouldProcessActionCaption
                )
            ) {
                $LocalVarUri = '/api/appliance/update/pending/{version}__action=install'
                $LocalVarMethod = 'POST'

                $useDeprecatedApis = ($null -ne $serverConfiguration.UseDeprecatedApis -and $serverConfiguration.UseDeprecatedApis)
                $translationSchema = $null
                $transformedOpertaionInput = New-InputTransformationStructure
                if ($useDeprecatedApis) {
                    # Use Deprecated APIs
                    $translationSchema = Get-OperationTranslationSchema `
                        -operationPath $LocalVarUri.Replace('__', '?') `
                        -operationVerb $LocalVarMethod
                    if ($null -ne $translationSchema) {
                        $LocalVarUri = $translationSchema.OldPath
                        $LocalVarMethod = $translationSchema.OldVerb
                    }
                }

                if (!$Version) {
                    throw "Error! The required parameter `Version` missing when calling installVersionPending."
                }
                $LocalVarUri = $LocalVarUri.replace('{version}', $Version)
                $LocalVarPathParameters['version'] = $Version
                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    $addTransformationInput = Format-PathParams -OperationTranslateSchema $translationSchema -PathParams $LocalVarPathParameters
                    Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                }
                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    $addTransformationInput = Format-Headers -OperationTranslateSchema $translationSchema -Headers $LocalVarHeaderParameters
                    Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                }
                if (
                    $useDeprecatedApis -and
                    ($null -ne $translationSchema) -and
                    ($LocalVarQueryParameters.Count -gt 0)
                ) {
                    $inputQuerySctructure = [PSCustomObject]$LocalVarQueryParameters
                    $translatedBody = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $inputQuerySctructure -InputType Body
                    $translatedQuery = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $inputQuerySctructure -InputType Query

                    if ($null -ne $translatedBody) {
                        $LocalVarBodyParameter = $translatedBody | ConvertTo-Json -Depth 100

                        if ($LocalVarContentTypes.Count -eq 0) {
                            $LocalVarContentTypes = @('application/json')
                        }
                    }
                    $LocalVarQueryParameters = @{}
                    $translatedQuery.PSObject.Properties | Foreach-Object { $LocalVarQueryParameters[$_.Name] = $_.Value }
                }

                if (!$UpdatePendingInstallRequestBody) {
                    throw "Error! The required parameter `UpdatePendingInstallRequestBody` missing when calling installVersionPending."
                }

                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    if ( $UpdatePendingInstallRequestBody -is [PSCustomObject]) {
                        $addTransformationInput = Format-Body -OperationTranslateSchema $translationSchema -Body ([ref]$UpdatePendingInstallRequestBody)
                        Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                    }

                    $tranlatedBody = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $UpdatePendingInstallRequestBody -InputType Body
                    $translatedQuery = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $UpdatePendingInstallRequestBody -InputType Query
                    if ($null -ne $translatedQuery) {
                        $LocalVarQueryParameters = @{}
                        $translatedQuery.PSObject.Properties | Foreach-Object { $LocalVarQueryParameters[$_.Name] = $_.Value }
                    }
                    $UpdatePendingInstallRequestBody = $tranlatedBody

                    if ($null -ne $transformedOpertaionInput.Path) {
                        foreach ($keyValue in $transformedOpertaionInput.Path.GetEnumerator()) {
                            $LocalVarUri = $LocalVarUri.replace("{$($keyValue.Key)}", $keyValue.Value)
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Query) {
                        foreach ($keyValue in $transformedOpertaionInput.Query.GetEnumerator()) {
                            $LocalVarQueryParameters[$($keyValue.Key)] = $keyValue.Value
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Header) {
                        foreach ($keyValue in $transformedOpertaionInput.Header.GetEnumerator()) {
                            $LocalVarHeaderParameters[$($keyValue.Key)] = $keyValue.Value
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Body) {
                        if ($null -ne $UpdatePendingInstallRequestBody) {
                            foreach ($keyValue in $transformedOpertaionInput.Body.GetEnumerator()) {
                                $UpdatePendingInstallRequestBody | Add-Member -MemberType NoteProperty -Name $keyValue.Key -Value $keyValue.Value
                            }
                        } else {
                            $UpdatePendingInstallRequestBody = [PSCustomObject]$($transformedOpertaionInput.Body)
                        }
                    }
                }

                if ($null -ne $UpdatePendingInstallRequestBody) {
                    $LocalVarBodyParameter = $UpdatePendingInstallRequestBody | ConvertTo-Json -Depth 100
                }

                $invokeParams = @{
                    'Method' = $LocalVarMethod
                    'Uri' = $LocalVarUri
                    'Accepts' = $LocalVarAccepts
                    'ContentTypes' = $LocalVarContentTypes
                    'Body' = $LocalVarBodyParameter
                    'HeaderParameters' = $LocalVarHeaderParameters
                    'QueryParameters' = $LocalVarQueryParameters
                    'FormParameters' = $LocalVarFormParameters
                    'CookieParameters' = $LocalVarCookieParameters
                    'ReturnType' = ""
                    'IsBodyNullable' = $false
                    'Server' = $serverConfiguration
                }

                if ($PSBoundParameters.ContainsKey('Debug')) {
                    $invokeParams['Debug'] = $Debug
                }

                if ($PSBoundParameters.ContainsKey('Verbose')) {
                    $invokeParams['Verbose'] = $Verbose
                }

                if ($PSBoundParameters.ContainsKey('WarningAction')) {
                    $invokeParams['WarningAction'] = $PSBoundParameters.WarningAction
                }

                if ($PSBoundParameters.ContainsKey('ErrorAction')) {
                    $invokeParams['ErrorAction'] = $PSBoundParameters.ErrorAction
                }

                $invokeParams['InvocationInfo'] = @{
                    'ModuleName' = $MyInvocation.MyCommand.ModuleName
                    'CmdletName' = $MyInvocation.MyCommand.Name
                }

                $invokeResult = Invoke-vSphereApiClient @invokeParams

                $invokeResult | Foreach-Object {
                    $SingleServerResult = $_
                    if ($SingleServerResult -is [hashtable]) {

                        if ($useDeprecatedApis -and ($null -ne $translationSchema) -and ($null -ne $SingleServerResult["Response"])) {
                            $ServerName = $SingleServerResult["Response"].PSObject.TypeNames | Where-Object -FilterScript { $_.StartsWith('Server:') }

                            $SingleServerResult["Response"] = Convert-OutputBody `
                                -OperationTranslateSchema $translationSchema `
                                -OperationOutputObject $SingleServerResult["Response"]

                            if (![string]::IsNullOrEmpty($ServerName)) {
                                $SingleServerResult["Response"] | ForEach-Object -Process {
                                    $_.PSObject.TypeNames.Add($ServerName)

                                    $_ = $_ | Add-Member -MemberType ScriptMethod -Name GetServer -Value {
                                        $productServerString = ($this.PSObject.TypeNames | Where-Object -FilterScript { $_.StartsWith('Server:') }).Substring(7)
                                        $productSeparatorIndex = $productServerString.IndexOf(':')

                                        $product = $productServerString.Substring(0, $productSeparatorIndex)
                                        $server = $productServerString.Substring($productSeparatorIndex + 1, $productServerString.Length - $productSeparatorIndex - 1)

                                        Get-ServerConfiguration -Product $product | Where-Object -FilterScript { $_.ToString() -eq $server }
                                    } -Force -PassThru

                                    $_.PSObject.TypeNames.Add("ServerObject")
                                }
                            }
                        }

                        if ($WithHttpInfo.IsPresent) {
                            # result object
                            $SingleServerResult
                        } else {
                            # result object
                            $SingleServerResult["Response"]
                        }

                    } else {
                        Write-Warning "An item from the Invoke-vSphereApiClient was expected to be a Hashtable but it is '$($SingleServerResult.GetType())'"
                    }
                }
            }
        }
    }
}

<#
.SYNOPSIS

Checks if there are any eligible updates.

.DESCRIPTION

No description available.

.PARAMETER SourceType
type of the source

.PARAMETER Url
specific URL to check at If unset then URL is taken from the policy settings

.PARAMETER EnableListMajorUpgradeVersions
checks and lists if there are eligible major version upgrades available. Possible values are true and false when set to true it allows listing of across version upgrade When not specified lists only minor updates available

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

UpdateSummary[]

.LINK

Online Version: https://developer.vmware.com/docs/vsphere-automation/latest/appliance/api/appliance/update/pending/get/
#>
function Invoke-ListUpdatePending {
    [CmdletBinding(
        SupportsShouldProcess = $true,
        ConfirmImpact = 'None',
        HelpURI = "https://developer.vmware.com/docs/vsphere-automation/latest/appliance/api/appliance/update/pending/get/"
    )]
    Param (
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ValidateSet("LAST_CHECK", "LOCAL", "LOCAL_AND_ONLINE")]
        ${SourceType},
        [Parameter(Mandatory = $false)]
        [ValidateScript({ $_ -is [string] })]
        ${Url},
        [Parameter(Mandatory = $false)]
        [System.Nullable[Boolean]]
        ${EnableListMajorUpgradeVersions},
        [Parameter()]
        [vSphereConnectionToServerConfigurationArgumentTransformationAttribute()]
        [PSTypeName('vSphereServerConfiguration')]
        $Server,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Invoke-ListUpdatePending' | Write-Debug

        $ServerConfigurations = Get-vSphereServerConfiguration
        if ($PSBoundParameters.ContainsKey('Server')) {
            $ServerConfigurations = $Server
        }

        if ($null -eq $ServerConfigurations) {
            throw "You are not currently connected to any servers. Please connect first using a Connect-VIServer cmdlet or add vSphere Server Configuration with New-vSphereServerConfiguration."
        }

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $ServerFromInputParameters = $null
        $InputParametersFromServer = $PSBoundParameters.Values | Where-Object -FilterScript { $_.PSObject.TypeNames -Contains 'ServerObject' }

        foreach ($InputParameterFromServer in $InputParametersFromServer) {
            $InputParameterServer = $InputParameterFromServer.GetServer()
            if (
                !$PSBoundParameters.ContainsKey('Server') -and
                $null -ne $ServerFromInputParameters -and
                !$ServerFromInputParameters.Equals($InputParameterServer)
            ) {
                $ErrorMessage = "{0} and {1} come from different servers. {0} from {2} and {1} from {3}. Please specify the -Server parameter of the cmdlet."
                throw ($ErrorMessage -f $ServerFromInputParameters.InputParameter, $InputParameterFromServer, $ServerFromInputParameters.Server, $InputParameterServer)
            }

            if ($null -eq $ServerFromInputParameters) {
                $ServerFromInputParameters = [PSCustomObject] @{
                    InputParameter = $InputParameterFromServer
                    Server = $InputParameterServer
                }
            }
        }

        if (
            $null -ne $ServerFromInputParameters -and
            $PSBoundParameters.ContainsKey('Server') -and
            !$ServerFromInputParameters.Server.Equals($Server)
        ) {
            $ErrorMessage = "{0} comes from server {1} but server {2} is explicitly specified."
            throw ($ErrorMessage -f $ServerFromInputParameters.InputParameter, $ServerFromInputParameters.Server, $Server)
        }

        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json')


        $serversToProcess = $ServerConfigurations

        if (!$PSBoundParameters.ContainsKey('Server') -and $null -ne $ServerFromInputParameters) {
            $serversToProcess = $ServerFromInputParameters.Server
        }

        foreach ($serverConfiguration in $serversToProcess) {
            $shouldProcessActionMessage = "Performing the operation 'ListUpdatePending' on target server '$($serverConfiguration.ToString())'."
            $shouldProcessActionCaption = 'Are you sure you want to perform this action?'

            if ($PSCmdlet.ShouldProcess(
                    $shouldProcessActionMessage,
                    $shouldProcessActionMessage,
                    $shouldProcessActionCaption
                )
            ) {
                $LocalVarUri = '/api/appliance/update/pending'
                $LocalVarMethod = 'GET'

                $useDeprecatedApis = ($null -ne $serverConfiguration.UseDeprecatedApis -and $serverConfiguration.UseDeprecatedApis)
                $translationSchema = $null
                $transformedOpertaionInput = New-InputTransformationStructure
                if ($useDeprecatedApis) {
                    # Use Deprecated APIs
                    $translationSchema = Get-OperationTranslationSchema `
                        -operationPath $LocalVarUri.Replace('__', '?') `
                        -operationVerb $LocalVarMethod
                    if ($null -ne $translationSchema) {
                        $LocalVarUri = $translationSchema.OldPath
                        $LocalVarMethod = $translationSchema.OldVerb
                    }
                }

                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    $addTransformationInput = Format-PathParams -OperationTranslateSchema $translationSchema -PathParams $LocalVarPathParameters
                    Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                }
                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    $addTransformationInput = Format-Headers -OperationTranslateSchema $translationSchema -Headers $LocalVarHeaderParameters
                    Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                }
                if (!$SourceType) {
                    throw "Error! The required parameter `SourceType` missing when calling listUpdatePending."
                }

                if ($null -ne $SourceType) {
                    $LocalVarQueryParameters['source_type'] = $SourceType
                }

                if (![string]::IsNullOrEmpty($Url)) {
                    $LocalVarQueryParameters['url'] = $Url
                }

                if ($null -ne $EnableListMajorUpgradeVersions) {
                    $LocalVarQueryParameters['enable_list_major_upgrade_versions'] = $EnableListMajorUpgradeVersions
                }

                if (
                    $useDeprecatedApis -and
                    ($null -ne $translationSchema) -and
                    ($LocalVarQueryParameters.Count -gt 0)
                ) {
                    $inputQuerySctructure = [PSCustomObject]$LocalVarQueryParameters
                    $translatedBody = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $inputQuerySctructure -InputType Body
                    $translatedQuery = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $inputQuerySctructure -InputType Query

                    if ($null -ne $translatedBody) {
                        $LocalVarBodyParameter = $translatedBody | ConvertTo-Json -Depth 100

                        if ($LocalVarContentTypes.Count -eq 0) {
                            $LocalVarContentTypes = @('application/json')
                        }
                    }
                    $LocalVarQueryParameters = @{}
                    $translatedQuery.PSObject.Properties | Foreach-Object { $LocalVarQueryParameters[$_.Name] = $_.Value }
                }

                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    if ($null -ne $transformedOpertaionInput.Path) {
                        foreach ($keyValue in $transformedOpertaionInput.Path.GetEnumerator()) {
                            $LocalVarUri = $LocalVarUri.replace("{$($keyValue.Key)}", $keyValue.Value)
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Query) {
                        foreach ($keyValue in $transformedOpertaionInput.Query.GetEnumerator()) {
                            $LocalVarQueryParameters[$($keyValue.Key)] = $keyValue.Value
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Header) {
                        foreach ($keyValue in $transformedOpertaionInput.Header.GetEnumerator()) {
                            $LocalVarHeaderParameters[$($keyValue.Key)] = $keyValue.Value
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Body) {
                         $LocalVarBodyParameter = $transformedOpertaionInput.Body | ConvertTo-Json -Depth 100
                    }
                }

                $invokeParams = @{
                    'Method' = $LocalVarMethod
                    'Uri' = $LocalVarUri
                    'Accepts' = $LocalVarAccepts
                    'ContentTypes' = $LocalVarContentTypes
                    'Body' = $LocalVarBodyParameter
                    'HeaderParameters' = $LocalVarHeaderParameters
                    'QueryParameters' = $LocalVarQueryParameters
                    'FormParameters' = $LocalVarFormParameters
                    'CookieParameters' = $LocalVarCookieParameters
                    'ReturnType' = "UpdateSummary[]"
                    'IsBodyNullable' = $false
                    'Server' = $serverConfiguration
                }

                if ($PSBoundParameters.ContainsKey('Debug')) {
                    $invokeParams['Debug'] = $Debug
                }

                if ($PSBoundParameters.ContainsKey('Verbose')) {
                    $invokeParams['Verbose'] = $Verbose
                }

                if ($PSBoundParameters.ContainsKey('WarningAction')) {
                    $invokeParams['WarningAction'] = $PSBoundParameters.WarningAction
                }

                if ($PSBoundParameters.ContainsKey('ErrorAction')) {
                    $invokeParams['ErrorAction'] = $PSBoundParameters.ErrorAction
                }

                $invokeParams['InvocationInfo'] = @{
                    'ModuleName' = $MyInvocation.MyCommand.ModuleName
                    'CmdletName' = $MyInvocation.MyCommand.Name
                }

                $invokeResult = Invoke-vSphereApiClient @invokeParams

                $invokeResult | Foreach-Object {
                    $SingleServerResult = $_
                    if ($SingleServerResult -is [hashtable]) {

                        if ($useDeprecatedApis -and ($null -ne $translationSchema) -and ($null -ne $SingleServerResult["Response"])) {
                            $ServerName = $SingleServerResult["Response"].PSObject.TypeNames | Where-Object -FilterScript { $_.StartsWith('Server:') }

                            $SingleServerResult["Response"] = Convert-OutputBody `
                                -OperationTranslateSchema $translationSchema `
                                -OperationOutputObject $SingleServerResult["Response"]

                            if (![string]::IsNullOrEmpty($ServerName)) {
                                $SingleServerResult["Response"] | ForEach-Object -Process {
                                    $_.PSObject.TypeNames.Add($ServerName)

                                    $_ = $_ | Add-Member -MemberType ScriptMethod -Name GetServer -Value {
                                        $productServerString = ($this.PSObject.TypeNames | Where-Object -FilterScript { $_.StartsWith('Server:') }).Substring(7)
                                        $productSeparatorIndex = $productServerString.IndexOf(':')

                                        $product = $productServerString.Substring(0, $productSeparatorIndex)
                                        $server = $productServerString.Substring($productSeparatorIndex + 1, $productServerString.Length - $productSeparatorIndex - 1)

                                        Get-ServerConfiguration -Product $product | Where-Object -FilterScript { $_.ToString() -eq $server }
                                    } -Force -PassThru

                                    $_.PSObject.TypeNames.Add("ServerObject")
                                }
                            }
                        }

                        foreach ($element in $SingleServerResult["Response"]) {
                            $element.PSObject.TypeNames.Insert(0, "UpdateSummary")
                        }

                        if ($WithHttpInfo.IsPresent) {
                            # result object
                            $SingleServerResult
                        } else {
                            # result object
                            $SingleServerResult["Response"]
                        }

                    } else {
                        Write-Warning "An item from the Invoke-vSphereApiClient was expected to be a Hashtable but it is '$($SingleServerResult.GetType())'"
                    }
                }
            }
        }
    }
}

<#
.SYNOPSIS

Runs update precheck

.DESCRIPTION

No description available.

.PARAMETER Version
Update version The parameter must be an identifier for the resource type: com.vmware.appliance.update.pending.

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

UpdatePendingPrecheckResult

.LINK

Online Version: https://developer.vmware.com/docs/vsphere-automation/latest/appliance/api/appliance/update/pending/versionactionprecheck/post/
#>
function Invoke-PrecheckVersionPending {
    [CmdletBinding(
        SupportsShouldProcess = $true,
        ConfirmImpact = 'Low',
        HelpURI = "https://developer.vmware.com/docs/vsphere-automation/latest/appliance/api/appliance/update/pending/versionactionprecheck/post/"
    )]
    Param (
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ValidateScript({ $_ -is [string] })]
        ${Version},
        [Parameter()]
        [vSphereConnectionToServerConfigurationArgumentTransformationAttribute()]
        [PSTypeName('vSphereServerConfiguration')]
        $Server,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Invoke-PrecheckVersionPending' | Write-Debug

        $ServerConfigurations = Get-vSphereServerConfiguration
        if ($PSBoundParameters.ContainsKey('Server')) {
            $ServerConfigurations = $Server
        }

        if ($null -eq $ServerConfigurations) {
            throw "You are not currently connected to any servers. Please connect first using a Connect-VIServer cmdlet or add vSphere Server Configuration with New-vSphereServerConfiguration."
        }

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $ServerFromInputParameters = $null
        $InputParametersFromServer = $PSBoundParameters.Values | Where-Object -FilterScript { $_.PSObject.TypeNames -Contains 'ServerObject' }

        foreach ($InputParameterFromServer in $InputParametersFromServer) {
            $InputParameterServer = $InputParameterFromServer.GetServer()
            if (
                !$PSBoundParameters.ContainsKey('Server') -and
                $null -ne $ServerFromInputParameters -and
                !$ServerFromInputParameters.Equals($InputParameterServer)
            ) {
                $ErrorMessage = "{0} and {1} come from different servers. {0} from {2} and {1} from {3}. Please specify the -Server parameter of the cmdlet."
                throw ($ErrorMessage -f $ServerFromInputParameters.InputParameter, $InputParameterFromServer, $ServerFromInputParameters.Server, $InputParameterServer)
            }

            if ($null -eq $ServerFromInputParameters) {
                $ServerFromInputParameters = [PSCustomObject] @{
                    InputParameter = $InputParameterFromServer
                    Server = $InputParameterServer
                }
            }
        }

        if (
            $null -ne $ServerFromInputParameters -and
            $PSBoundParameters.ContainsKey('Server') -and
            !$ServerFromInputParameters.Server.Equals($Server)
        ) {
            $ErrorMessage = "{0} comes from server {1} but server {2} is explicitly specified."
            throw ($ErrorMessage -f $ServerFromInputParameters.InputParameter, $ServerFromInputParameters.Server, $Server)
        }

        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json')


        $serversToProcess = $ServerConfigurations

        if (!$PSBoundParameters.ContainsKey('Server') -and $null -ne $ServerFromInputParameters) {
            $serversToProcess = $ServerFromInputParameters.Server
        }

        foreach ($serverConfiguration in $serversToProcess) {
            $shouldProcessActionMessage = "Performing the operation 'PrecheckVersionPending' on target server '$($serverConfiguration.ToString())'."
            $shouldProcessActionCaption = 'Are you sure you want to perform this action?'

            if ($PSCmdlet.ShouldProcess(
                    $shouldProcessActionMessage,
                    $shouldProcessActionMessage,
                    $shouldProcessActionCaption
                )
            ) {
                $LocalVarUri = '/api/appliance/update/pending/{version}__action=precheck'
                $LocalVarMethod = 'POST'

                $useDeprecatedApis = ($null -ne $serverConfiguration.UseDeprecatedApis -and $serverConfiguration.UseDeprecatedApis)
                $translationSchema = $null
                $transformedOpertaionInput = New-InputTransformationStructure
                if ($useDeprecatedApis) {
                    # Use Deprecated APIs
                    $translationSchema = Get-OperationTranslationSchema `
                        -operationPath $LocalVarUri.Replace('__', '?') `
                        -operationVerb $LocalVarMethod
                    if ($null -ne $translationSchema) {
                        $LocalVarUri = $translationSchema.OldPath
                        $LocalVarMethod = $translationSchema.OldVerb
                    }
                }

                if (!$Version) {
                    throw "Error! The required parameter `Version` missing when calling precheckVersionPending."
                }
                $LocalVarUri = $LocalVarUri.replace('{version}', $Version)
                $LocalVarPathParameters['version'] = $Version
                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    $addTransformationInput = Format-PathParams -OperationTranslateSchema $translationSchema -PathParams $LocalVarPathParameters
                    Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                }
                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    $addTransformationInput = Format-Headers -OperationTranslateSchema $translationSchema -Headers $LocalVarHeaderParameters
                    Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                }
                if (
                    $useDeprecatedApis -and
                    ($null -ne $translationSchema) -and
                    ($LocalVarQueryParameters.Count -gt 0)
                ) {
                    $inputQuerySctructure = [PSCustomObject]$LocalVarQueryParameters
                    $translatedBody = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $inputQuerySctructure -InputType Body
                    $translatedQuery = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $inputQuerySctructure -InputType Query

                    if ($null -ne $translatedBody) {
                        $LocalVarBodyParameter = $translatedBody | ConvertTo-Json -Depth 100

                        if ($LocalVarContentTypes.Count -eq 0) {
                            $LocalVarContentTypes = @('application/json')
                        }
                    }
                    $LocalVarQueryParameters = @{}
                    $translatedQuery.PSObject.Properties | Foreach-Object { $LocalVarQueryParameters[$_.Name] = $_.Value }
                }

                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    if ($null -ne $transformedOpertaionInput.Path) {
                        foreach ($keyValue in $transformedOpertaionInput.Path.GetEnumerator()) {
                            $LocalVarUri = $LocalVarUri.replace("{$($keyValue.Key)}", $keyValue.Value)
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Query) {
                        foreach ($keyValue in $transformedOpertaionInput.Query.GetEnumerator()) {
                            $LocalVarQueryParameters[$($keyValue.Key)] = $keyValue.Value
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Header) {
                        foreach ($keyValue in $transformedOpertaionInput.Header.GetEnumerator()) {
                            $LocalVarHeaderParameters[$($keyValue.Key)] = $keyValue.Value
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Body) {
                         $LocalVarBodyParameter = $transformedOpertaionInput.Body | ConvertTo-Json -Depth 100
                    }
                }

                $invokeParams = @{
                    'Method' = $LocalVarMethod
                    'Uri' = $LocalVarUri
                    'Accepts' = $LocalVarAccepts
                    'ContentTypes' = $LocalVarContentTypes
                    'Body' = $LocalVarBodyParameter
                    'HeaderParameters' = $LocalVarHeaderParameters
                    'QueryParameters' = $LocalVarQueryParameters
                    'FormParameters' = $LocalVarFormParameters
                    'CookieParameters' = $LocalVarCookieParameters
                    'ReturnType' = "UpdatePendingPrecheckResult"
                    'IsBodyNullable' = $false
                    'Server' = $serverConfiguration
                }

                if ($PSBoundParameters.ContainsKey('Debug')) {
                    $invokeParams['Debug'] = $Debug
                }

                if ($PSBoundParameters.ContainsKey('Verbose')) {
                    $invokeParams['Verbose'] = $Verbose
                }

                if ($PSBoundParameters.ContainsKey('WarningAction')) {
                    $invokeParams['WarningAction'] = $PSBoundParameters.WarningAction
                }

                if ($PSBoundParameters.ContainsKey('ErrorAction')) {
                    $invokeParams['ErrorAction'] = $PSBoundParameters.ErrorAction
                }

                $invokeParams['InvocationInfo'] = @{
                    'ModuleName' = $MyInvocation.MyCommand.ModuleName
                    'CmdletName' = $MyInvocation.MyCommand.Name
                }

                $invokeResult = Invoke-vSphereApiClient @invokeParams

                $invokeResult | Foreach-Object {
                    $SingleServerResult = $_
                    if ($SingleServerResult -is [hashtable]) {

                        if ($useDeprecatedApis -and ($null -ne $translationSchema) -and ($null -ne $SingleServerResult["Response"])) {
                            $ServerName = $SingleServerResult["Response"].PSObject.TypeNames | Where-Object -FilterScript { $_.StartsWith('Server:') }

                            $SingleServerResult["Response"] = Convert-OutputBody `
                                -OperationTranslateSchema $translationSchema `
                                -OperationOutputObject $SingleServerResult["Response"]

                            if (![string]::IsNullOrEmpty($ServerName)) {
                                $SingleServerResult["Response"] | ForEach-Object -Process {
                                    $_.PSObject.TypeNames.Add($ServerName)

                                    $_ = $_ | Add-Member -MemberType ScriptMethod -Name GetServer -Value {
                                        $productServerString = ($this.PSObject.TypeNames | Where-Object -FilterScript { $_.StartsWith('Server:') }).Substring(7)
                                        $productSeparatorIndex = $productServerString.IndexOf(':')

                                        $product = $productServerString.Substring(0, $productSeparatorIndex)
                                        $server = $productServerString.Substring($productSeparatorIndex + 1, $productServerString.Length - $productSeparatorIndex - 1)

                                        Get-ServerConfiguration -Product $product | Where-Object -FilterScript { $_.ToString() -eq $server }
                                    } -Force -PassThru

                                    $_.PSObject.TypeNames.Add("ServerObject")
                                }
                            }
                        }

                        $SingleServerResult["Response"].PSObject.TypeNames.Insert(0, "UpdatePendingPrecheckResult")

                        if ($WithHttpInfo.IsPresent) {
                            # result object
                            $SingleServerResult
                        } else {
                            # result object
                            $SingleServerResult["Response"]
                        }

                    } else {
                        Write-Warning "An item from the Invoke-vSphereApiClient was expected to be a Hashtable but it is '$($SingleServerResult.GetType())'"
                    }
                }
            }
        }
    }
}

<#
.SYNOPSIS

Starts operation of installing the appliance update. Will stage update if not already staged The updates are searched for in the following order: staged, CDROM, URL

.DESCRIPTION

No description available.

.PARAMETER Version
Update version The parameter must be an identifier for the resource type: com.vmware.appliance.update.pending.

.PARAMETER UpdatePendingStageAndInstallRequestBody
No description available.

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

None

.LINK

Online Version: https://developer.vmware.com/docs/vsphere-automation/latest/appliance/api/appliance/update/pending/versionactionstage-and-install/post/
#>
function Invoke-StageAndInstallVersionPending {
    [CmdletBinding(
        SupportsShouldProcess = $true,
        ConfirmImpact = 'Low',
        HelpURI = "https://developer.vmware.com/docs/vsphere-automation/latest/appliance/api/appliance/update/pending/versionactionstage-and-install/post/"
    )]
    Param (
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ValidateScript({ $_ -is [string] })]
        ${Version},
        [Parameter(Mandatory = $true)]
        [PSTypeName("UpdatePendingStageAndInstallRequestBody")]
        [PSCustomObject]
        ${UpdatePendingStageAndInstallRequestBody},
        [Parameter()]
        [vSphereConnectionToServerConfigurationArgumentTransformationAttribute()]
        [PSTypeName('vSphereServerConfiguration')]
        $Server,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Invoke-StageAndInstallVersionPending' | Write-Debug

        $ServerConfigurations = Get-vSphereServerConfiguration
        if ($PSBoundParameters.ContainsKey('Server')) {
            $ServerConfigurations = $Server
        }

        if ($null -eq $ServerConfigurations) {
            throw "You are not currently connected to any servers. Please connect first using a Connect-VIServer cmdlet or add vSphere Server Configuration with New-vSphereServerConfiguration."
        }

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $ServerFromInputParameters = $null
        $InputParametersFromServer = $PSBoundParameters.Values | Where-Object -FilterScript { $_.PSObject.TypeNames -Contains 'ServerObject' }

        foreach ($InputParameterFromServer in $InputParametersFromServer) {
            $InputParameterServer = $InputParameterFromServer.GetServer()
            if (
                !$PSBoundParameters.ContainsKey('Server') -and
                $null -ne $ServerFromInputParameters -and
                !$ServerFromInputParameters.Equals($InputParameterServer)
            ) {
                $ErrorMessage = "{0} and {1} come from different servers. {0} from {2} and {1} from {3}. Please specify the -Server parameter of the cmdlet."
                throw ($ErrorMessage -f $ServerFromInputParameters.InputParameter, $InputParameterFromServer, $ServerFromInputParameters.Server, $InputParameterServer)
            }

            if ($null -eq $ServerFromInputParameters) {
                $ServerFromInputParameters = [PSCustomObject] @{
                    InputParameter = $InputParameterFromServer
                    Server = $InputParameterServer
                }
            }
        }

        if (
            $null -ne $ServerFromInputParameters -and
            $PSBoundParameters.ContainsKey('Server') -and
            !$ServerFromInputParameters.Server.Equals($Server)
        ) {
            $ErrorMessage = "{0} comes from server {1} but server {2} is explicitly specified."
            throw ($ErrorMessage -f $ServerFromInputParameters.InputParameter, $ServerFromInputParameters.Server, $Server)
        }

        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json')

        # HTTP header 'Content-Type'
        $LocalVarContentTypes = @('application/json')


        $serversToProcess = $ServerConfigurations

        if (!$PSBoundParameters.ContainsKey('Server') -and $null -ne $ServerFromInputParameters) {
            $serversToProcess = $ServerFromInputParameters.Server
        }

        foreach ($serverConfiguration in $serversToProcess) {
            $shouldProcessActionMessage = "Performing the operation 'StageAndInstallVersionPending' on target server '$($serverConfiguration.ToString())'."
            $shouldProcessActionCaption = 'Are you sure you want to perform this action?'

            if ($PSCmdlet.ShouldProcess(
                    $shouldProcessActionMessage,
                    $shouldProcessActionMessage,
                    $shouldProcessActionCaption
                )
            ) {
                $LocalVarUri = '/api/appliance/update/pending/{version}__action=stage-and-install'
                $LocalVarMethod = 'POST'

                $useDeprecatedApis = ($null -ne $serverConfiguration.UseDeprecatedApis -and $serverConfiguration.UseDeprecatedApis)
                $translationSchema = $null
                $transformedOpertaionInput = New-InputTransformationStructure
                if ($useDeprecatedApis) {
                    # Use Deprecated APIs
                    $translationSchema = Get-OperationTranslationSchema `
                        -operationPath $LocalVarUri.Replace('__', '?') `
                        -operationVerb $LocalVarMethod
                    if ($null -ne $translationSchema) {
                        $LocalVarUri = $translationSchema.OldPath
                        $LocalVarMethod = $translationSchema.OldVerb
                    }
                }

                if (!$Version) {
                    throw "Error! The required parameter `Version` missing when calling stageAndInstallVersionPending."
                }
                $LocalVarUri = $LocalVarUri.replace('{version}', $Version)
                $LocalVarPathParameters['version'] = $Version
                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    $addTransformationInput = Format-PathParams -OperationTranslateSchema $translationSchema -PathParams $LocalVarPathParameters
                    Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                }
                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    $addTransformationInput = Format-Headers -OperationTranslateSchema $translationSchema -Headers $LocalVarHeaderParameters
                    Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                }
                if (
                    $useDeprecatedApis -and
                    ($null -ne $translationSchema) -and
                    ($LocalVarQueryParameters.Count -gt 0)
                ) {
                    $inputQuerySctructure = [PSCustomObject]$LocalVarQueryParameters
                    $translatedBody = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $inputQuerySctructure -InputType Body
                    $translatedQuery = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $inputQuerySctructure -InputType Query

                    if ($null -ne $translatedBody) {
                        $LocalVarBodyParameter = $translatedBody | ConvertTo-Json -Depth 100

                        if ($LocalVarContentTypes.Count -eq 0) {
                            $LocalVarContentTypes = @('application/json')
                        }
                    }
                    $LocalVarQueryParameters = @{}
                    $translatedQuery.PSObject.Properties | Foreach-Object { $LocalVarQueryParameters[$_.Name] = $_.Value }
                }

                if (!$UpdatePendingStageAndInstallRequestBody) {
                    throw "Error! The required parameter `UpdatePendingStageAndInstallRequestBody` missing when calling stageAndInstallVersionPending."
                }

                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    if ( $UpdatePendingStageAndInstallRequestBody -is [PSCustomObject]) {
                        $addTransformationInput = Format-Body -OperationTranslateSchema $translationSchema -Body ([ref]$UpdatePendingStageAndInstallRequestBody)
                        Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                    }

                    $tranlatedBody = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $UpdatePendingStageAndInstallRequestBody -InputType Body
                    $translatedQuery = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $UpdatePendingStageAndInstallRequestBody -InputType Query
                    if ($null -ne $translatedQuery) {
                        $LocalVarQueryParameters = @{}
                        $translatedQuery.PSObject.Properties | Foreach-Object { $LocalVarQueryParameters[$_.Name] = $_.Value }
                    }
                    $UpdatePendingStageAndInstallRequestBody = $tranlatedBody

                    if ($null -ne $transformedOpertaionInput.Path) {
                        foreach ($keyValue in $transformedOpertaionInput.Path.GetEnumerator()) {
                            $LocalVarUri = $LocalVarUri.replace("{$($keyValue.Key)}", $keyValue.Value)
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Query) {
                        foreach ($keyValue in $transformedOpertaionInput.Query.GetEnumerator()) {
                            $LocalVarQueryParameters[$($keyValue.Key)] = $keyValue.Value
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Header) {
                        foreach ($keyValue in $transformedOpertaionInput.Header.GetEnumerator()) {
                            $LocalVarHeaderParameters[$($keyValue.Key)] = $keyValue.Value
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Body) {
                        if ($null -ne $UpdatePendingStageAndInstallRequestBody) {
                            foreach ($keyValue in $transformedOpertaionInput.Body.GetEnumerator()) {
                                $UpdatePendingStageAndInstallRequestBody | Add-Member -MemberType NoteProperty -Name $keyValue.Key -Value $keyValue.Value
                            }
                        } else {
                            $UpdatePendingStageAndInstallRequestBody = [PSCustomObject]$($transformedOpertaionInput.Body)
                        }
                    }
                }

                if ($null -ne $UpdatePendingStageAndInstallRequestBody) {
                    $LocalVarBodyParameter = $UpdatePendingStageAndInstallRequestBody | ConvertTo-Json -Depth 100
                }

                $invokeParams = @{
                    'Method' = $LocalVarMethod
                    'Uri' = $LocalVarUri
                    'Accepts' = $LocalVarAccepts
                    'ContentTypes' = $LocalVarContentTypes
                    'Body' = $LocalVarBodyParameter
                    'HeaderParameters' = $LocalVarHeaderParameters
                    'QueryParameters' = $LocalVarQueryParameters
                    'FormParameters' = $LocalVarFormParameters
                    'CookieParameters' = $LocalVarCookieParameters
                    'ReturnType' = ""
                    'IsBodyNullable' = $false
                    'Server' = $serverConfiguration
                }

                if ($PSBoundParameters.ContainsKey('Debug')) {
                    $invokeParams['Debug'] = $Debug
                }

                if ($PSBoundParameters.ContainsKey('Verbose')) {
                    $invokeParams['Verbose'] = $Verbose
                }

                if ($PSBoundParameters.ContainsKey('WarningAction')) {
                    $invokeParams['WarningAction'] = $PSBoundParameters.WarningAction
                }

                if ($PSBoundParameters.ContainsKey('ErrorAction')) {
                    $invokeParams['ErrorAction'] = $PSBoundParameters.ErrorAction
                }

                $invokeParams['InvocationInfo'] = @{
                    'ModuleName' = $MyInvocation.MyCommand.ModuleName
                    'CmdletName' = $MyInvocation.MyCommand.Name
                }

                $invokeResult = Invoke-vSphereApiClient @invokeParams

                $invokeResult | Foreach-Object {
                    $SingleServerResult = $_
                    if ($SingleServerResult -is [hashtable]) {

                        if ($useDeprecatedApis -and ($null -ne $translationSchema) -and ($null -ne $SingleServerResult["Response"])) {
                            $ServerName = $SingleServerResult["Response"].PSObject.TypeNames | Where-Object -FilterScript { $_.StartsWith('Server:') }

                            $SingleServerResult["Response"] = Convert-OutputBody `
                                -OperationTranslateSchema $translationSchema `
                                -OperationOutputObject $SingleServerResult["Response"]

                            if (![string]::IsNullOrEmpty($ServerName)) {
                                $SingleServerResult["Response"] | ForEach-Object -Process {
                                    $_.PSObject.TypeNames.Add($ServerName)

                                    $_ = $_ | Add-Member -MemberType ScriptMethod -Name GetServer -Value {
                                        $productServerString = ($this.PSObject.TypeNames | Where-Object -FilterScript { $_.StartsWith('Server:') }).Substring(7)
                                        $productSeparatorIndex = $productServerString.IndexOf(':')

                                        $product = $productServerString.Substring(0, $productSeparatorIndex)
                                        $server = $productServerString.Substring($productSeparatorIndex + 1, $productServerString.Length - $productSeparatorIndex - 1)

                                        Get-ServerConfiguration -Product $product | Where-Object -FilterScript { $_.ToString() -eq $server }
                                    } -Force -PassThru

                                    $_.PSObject.TypeNames.Add("ServerObject")
                                }
                            }
                        }

                        if ($WithHttpInfo.IsPresent) {
                            # result object
                            $SingleServerResult
                        } else {
                            # result object
                            $SingleServerResult["Response"]
                        }

                    } else {
                        Write-Warning "An item from the Invoke-vSphereApiClient was expected to be a Hashtable but it is '$($SingleServerResult.GetType())'"
                    }
                }
            }
        }
    }
}

<#
.SYNOPSIS

Starts staging the appliance update. The updates are searched for in the following order: staged, CDROM, URL

.DESCRIPTION

No description available.

.PARAMETER Version
Update version The parameter must be an identifier for the resource type: com.vmware.appliance.update.pending.

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

None

.LINK

Online Version: https://developer.vmware.com/docs/vsphere-automation/latest/appliance/api/appliance/update/pending/versionactionstage/post/
#>
function Invoke-StageVersionPending {
    [CmdletBinding(
        SupportsShouldProcess = $true,
        ConfirmImpact = 'Low',
        HelpURI = "https://developer.vmware.com/docs/vsphere-automation/latest/appliance/api/appliance/update/pending/versionactionstage/post/"
    )]
    Param (
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ValidateScript({ $_ -is [string] })]
        ${Version},
        [Parameter()]
        [vSphereConnectionToServerConfigurationArgumentTransformationAttribute()]
        [PSTypeName('vSphereServerConfiguration')]
        $Server,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Invoke-StageVersionPending' | Write-Debug

        $ServerConfigurations = Get-vSphereServerConfiguration
        if ($PSBoundParameters.ContainsKey('Server')) {
            $ServerConfigurations = $Server
        }

        if ($null -eq $ServerConfigurations) {
            throw "You are not currently connected to any servers. Please connect first using a Connect-VIServer cmdlet or add vSphere Server Configuration with New-vSphereServerConfiguration."
        }

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $ServerFromInputParameters = $null
        $InputParametersFromServer = $PSBoundParameters.Values | Where-Object -FilterScript { $_.PSObject.TypeNames -Contains 'ServerObject' }

        foreach ($InputParameterFromServer in $InputParametersFromServer) {
            $InputParameterServer = $InputParameterFromServer.GetServer()
            if (
                !$PSBoundParameters.ContainsKey('Server') -and
                $null -ne $ServerFromInputParameters -and
                !$ServerFromInputParameters.Equals($InputParameterServer)
            ) {
                $ErrorMessage = "{0} and {1} come from different servers. {0} from {2} and {1} from {3}. Please specify the -Server parameter of the cmdlet."
                throw ($ErrorMessage -f $ServerFromInputParameters.InputParameter, $InputParameterFromServer, $ServerFromInputParameters.Server, $InputParameterServer)
            }

            if ($null -eq $ServerFromInputParameters) {
                $ServerFromInputParameters = [PSCustomObject] @{
                    InputParameter = $InputParameterFromServer
                    Server = $InputParameterServer
                }
            }
        }

        if (
            $null -ne $ServerFromInputParameters -and
            $PSBoundParameters.ContainsKey('Server') -and
            !$ServerFromInputParameters.Server.Equals($Server)
        ) {
            $ErrorMessage = "{0} comes from server {1} but server {2} is explicitly specified."
            throw ($ErrorMessage -f $ServerFromInputParameters.InputParameter, $ServerFromInputParameters.Server, $Server)
        }

        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json')


        $serversToProcess = $ServerConfigurations

        if (!$PSBoundParameters.ContainsKey('Server') -and $null -ne $ServerFromInputParameters) {
            $serversToProcess = $ServerFromInputParameters.Server
        }

        foreach ($serverConfiguration in $serversToProcess) {
            $shouldProcessActionMessage = "Performing the operation 'StageVersionPending' on target server '$($serverConfiguration.ToString())'."
            $shouldProcessActionCaption = 'Are you sure you want to perform this action?'

            if ($PSCmdlet.ShouldProcess(
                    $shouldProcessActionMessage,
                    $shouldProcessActionMessage,
                    $shouldProcessActionCaption
                )
            ) {
                $LocalVarUri = '/api/appliance/update/pending/{version}__action=stage'
                $LocalVarMethod = 'POST'

                $useDeprecatedApis = ($null -ne $serverConfiguration.UseDeprecatedApis -and $serverConfiguration.UseDeprecatedApis)
                $translationSchema = $null
                $transformedOpertaionInput = New-InputTransformationStructure
                if ($useDeprecatedApis) {
                    # Use Deprecated APIs
                    $translationSchema = Get-OperationTranslationSchema `
                        -operationPath $LocalVarUri.Replace('__', '?') `
                        -operationVerb $LocalVarMethod
                    if ($null -ne $translationSchema) {
                        $LocalVarUri = $translationSchema.OldPath
                        $LocalVarMethod = $translationSchema.OldVerb
                    }
                }

                if (!$Version) {
                    throw "Error! The required parameter `Version` missing when calling stageVersionPending."
                }
                $LocalVarUri = $LocalVarUri.replace('{version}', $Version)
                $LocalVarPathParameters['version'] = $Version
                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    $addTransformationInput = Format-PathParams -OperationTranslateSchema $translationSchema -PathParams $LocalVarPathParameters
                    Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                }
                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    $addTransformationInput = Format-Headers -OperationTranslateSchema $translationSchema -Headers $LocalVarHeaderParameters
                    Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                }
                if (
                    $useDeprecatedApis -and
                    ($null -ne $translationSchema) -and
                    ($LocalVarQueryParameters.Count -gt 0)
                ) {
                    $inputQuerySctructure = [PSCustomObject]$LocalVarQueryParameters
                    $translatedBody = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $inputQuerySctructure -InputType Body
                    $translatedQuery = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $inputQuerySctructure -InputType Query

                    if ($null -ne $translatedBody) {
                        $LocalVarBodyParameter = $translatedBody | ConvertTo-Json -Depth 100

                        if ($LocalVarContentTypes.Count -eq 0) {
                            $LocalVarContentTypes = @('application/json')
                        }
                    }
                    $LocalVarQueryParameters = @{}
                    $translatedQuery.PSObject.Properties | Foreach-Object { $LocalVarQueryParameters[$_.Name] = $_.Value }
                }

                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    if ($null -ne $transformedOpertaionInput.Path) {
                        foreach ($keyValue in $transformedOpertaionInput.Path.GetEnumerator()) {
                            $LocalVarUri = $LocalVarUri.replace("{$($keyValue.Key)}", $keyValue.Value)
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Query) {
                        foreach ($keyValue in $transformedOpertaionInput.Query.GetEnumerator()) {
                            $LocalVarQueryParameters[$($keyValue.Key)] = $keyValue.Value
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Header) {
                        foreach ($keyValue in $transformedOpertaionInput.Header.GetEnumerator()) {
                            $LocalVarHeaderParameters[$($keyValue.Key)] = $keyValue.Value
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Body) {
                         $LocalVarBodyParameter = $transformedOpertaionInput.Body | ConvertTo-Json -Depth 100
                    }
                }

                $invokeParams = @{
                    'Method' = $LocalVarMethod
                    'Uri' = $LocalVarUri
                    'Accepts' = $LocalVarAccepts
                    'ContentTypes' = $LocalVarContentTypes
                    'Body' = $LocalVarBodyParameter
                    'HeaderParameters' = $LocalVarHeaderParameters
                    'QueryParameters' = $LocalVarQueryParameters
                    'FormParameters' = $LocalVarFormParameters
                    'CookieParameters' = $LocalVarCookieParameters
                    'ReturnType' = ""
                    'IsBodyNullable' = $false
                    'Server' = $serverConfiguration
                }

                if ($PSBoundParameters.ContainsKey('Debug')) {
                    $invokeParams['Debug'] = $Debug
                }

                if ($PSBoundParameters.ContainsKey('Verbose')) {
                    $invokeParams['Verbose'] = $Verbose
                }

                if ($PSBoundParameters.ContainsKey('WarningAction')) {
                    $invokeParams['WarningAction'] = $PSBoundParameters.WarningAction
                }

                if ($PSBoundParameters.ContainsKey('ErrorAction')) {
                    $invokeParams['ErrorAction'] = $PSBoundParameters.ErrorAction
                }

                $invokeParams['InvocationInfo'] = @{
                    'ModuleName' = $MyInvocation.MyCommand.ModuleName
                    'CmdletName' = $MyInvocation.MyCommand.Name
                }

                $invokeResult = Invoke-vSphereApiClient @invokeParams

                $invokeResult | Foreach-Object {
                    $SingleServerResult = $_
                    if ($SingleServerResult -is [hashtable]) {

                        if ($useDeprecatedApis -and ($null -ne $translationSchema) -and ($null -ne $SingleServerResult["Response"])) {
                            $ServerName = $SingleServerResult["Response"].PSObject.TypeNames | Where-Object -FilterScript { $_.StartsWith('Server:') }

                            $SingleServerResult["Response"] = Convert-OutputBody `
                                -OperationTranslateSchema $translationSchema `
                                -OperationOutputObject $SingleServerResult["Response"]

                            if (![string]::IsNullOrEmpty($ServerName)) {
                                $SingleServerResult["Response"] | ForEach-Object -Process {
                                    $_.PSObject.TypeNames.Add($ServerName)

                                    $_ = $_ | Add-Member -MemberType ScriptMethod -Name GetServer -Value {
                                        $productServerString = ($this.PSObject.TypeNames | Where-Object -FilterScript { $_.StartsWith('Server:') }).Substring(7)
                                        $productSeparatorIndex = $productServerString.IndexOf(':')

                                        $product = $productServerString.Substring(0, $productSeparatorIndex)
                                        $server = $productServerString.Substring($productSeparatorIndex + 1, $productServerString.Length - $productSeparatorIndex - 1)

                                        Get-ServerConfiguration -Product $product | Where-Object -FilterScript { $_.ToString() -eq $server }
                                    } -Force -PassThru

                                    $_.PSObject.TypeNames.Add("ServerObject")
                                }
                            }
                        }

                        if ($WithHttpInfo.IsPresent) {
                            # result object
                            $SingleServerResult
                        } else {
                            # result object
                            $SingleServerResult["Response"]
                        }

                    } else {
                        Write-Warning "An item from the Invoke-vSphereApiClient was expected to be a Hashtable but it is '$($SingleServerResult.GetType())'"
                    }
                }
            }
        }
    }
}

<#
.SYNOPSIS

Validates the user provided data before the update installation.

.DESCRIPTION

No description available.

.PARAMETER Version
Update version The parameter must be an identifier for the resource type: com.vmware.appliance.update.pending.

.PARAMETER UpdatePendingValidateRequestBody
No description available.

.PARAMETER WithHttpInfo

A switch when turned on will return a hash table of Response, StatusCode and Headers instead of just the Response

.OUTPUTS

Notifications

.LINK

Online Version: https://developer.vmware.com/docs/vsphere-automation/latest/appliance/api/appliance/update/pending/versionactionvalidate/post/
#>
function Invoke-ValidateVersionPending {
    [CmdletBinding(
        SupportsShouldProcess = $true,
        ConfirmImpact = 'Low',
        HelpURI = "https://developer.vmware.com/docs/vsphere-automation/latest/appliance/api/appliance/update/pending/versionactionvalidate/post/"
    )]
    Param (
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ValidateScript({ $_ -is [string] })]
        ${Version},
        [Parameter(Mandatory = $true)]
        [PSTypeName("UpdatePendingValidateRequestBody")]
        [PSCustomObject]
        ${UpdatePendingValidateRequestBody},
        [Parameter()]
        [vSphereConnectionToServerConfigurationArgumentTransformationAttribute()]
        [PSTypeName('vSphereServerConfiguration')]
        $Server,
        [Switch]
        $WithHttpInfo
    )

    Process {
        'Calling method: Invoke-ValidateVersionPending' | Write-Debug

        $ServerConfigurations = Get-vSphereServerConfiguration
        if ($PSBoundParameters.ContainsKey('Server')) {
            $ServerConfigurations = $Server
        }

        if ($null -eq $ServerConfigurations) {
            throw "You are not currently connected to any servers. Please connect first using a Connect-VIServer cmdlet or add vSphere Server Configuration with New-vSphereServerConfiguration."
        }

        $LocalVarAccepts = @()
        $LocalVarContentTypes = @()
        $LocalVarQueryParameters = @{}
        $LocalVarHeaderParameters = @{}
        $LocalVarFormParameters = @{}
        $LocalVarPathParameters = @{}
        $LocalVarCookieParameters = @{}
        $LocalVarBodyParameter = $null

        $ServerFromInputParameters = $null
        $InputParametersFromServer = $PSBoundParameters.Values | Where-Object -FilterScript { $_.PSObject.TypeNames -Contains 'ServerObject' }

        foreach ($InputParameterFromServer in $InputParametersFromServer) {
            $InputParameterServer = $InputParameterFromServer.GetServer()
            if (
                !$PSBoundParameters.ContainsKey('Server') -and
                $null -ne $ServerFromInputParameters -and
                !$ServerFromInputParameters.Equals($InputParameterServer)
            ) {
                $ErrorMessage = "{0} and {1} come from different servers. {0} from {2} and {1} from {3}. Please specify the -Server parameter of the cmdlet."
                throw ($ErrorMessage -f $ServerFromInputParameters.InputParameter, $InputParameterFromServer, $ServerFromInputParameters.Server, $InputParameterServer)
            }

            if ($null -eq $ServerFromInputParameters) {
                $ServerFromInputParameters = [PSCustomObject] @{
                    InputParameter = $InputParameterFromServer
                    Server = $InputParameterServer
                }
            }
        }

        if (
            $null -ne $ServerFromInputParameters -and
            $PSBoundParameters.ContainsKey('Server') -and
            !$ServerFromInputParameters.Server.Equals($Server)
        ) {
            $ErrorMessage = "{0} comes from server {1} but server {2} is explicitly specified."
            throw ($ErrorMessage -f $ServerFromInputParameters.InputParameter, $ServerFromInputParameters.Server, $Server)
        }

        # HTTP header 'Accept' (if needed)
        $LocalVarAccepts = @('application/json')

        # HTTP header 'Content-Type'
        $LocalVarContentTypes = @('application/json')


        $serversToProcess = $ServerConfigurations

        if (!$PSBoundParameters.ContainsKey('Server') -and $null -ne $ServerFromInputParameters) {
            $serversToProcess = $ServerFromInputParameters.Server
        }

        foreach ($serverConfiguration in $serversToProcess) {
            $shouldProcessActionMessage = "Performing the operation 'ValidateVersionPending' on target server '$($serverConfiguration.ToString())'."
            $shouldProcessActionCaption = 'Are you sure you want to perform this action?'

            if ($PSCmdlet.ShouldProcess(
                    $shouldProcessActionMessage,
                    $shouldProcessActionMessage,
                    $shouldProcessActionCaption
                )
            ) {
                $LocalVarUri = '/api/appliance/update/pending/{version}__action=validate'
                $LocalVarMethod = 'POST'

                $useDeprecatedApis = ($null -ne $serverConfiguration.UseDeprecatedApis -and $serverConfiguration.UseDeprecatedApis)
                $translationSchema = $null
                $transformedOpertaionInput = New-InputTransformationStructure
                if ($useDeprecatedApis) {
                    # Use Deprecated APIs
                    $translationSchema = Get-OperationTranslationSchema `
                        -operationPath $LocalVarUri.Replace('__', '?') `
                        -operationVerb $LocalVarMethod
                    if ($null -ne $translationSchema) {
                        $LocalVarUri = $translationSchema.OldPath
                        $LocalVarMethod = $translationSchema.OldVerb
                    }
                }

                if (!$Version) {
                    throw "Error! The required parameter `Version` missing when calling validateVersionPending."
                }
                $LocalVarUri = $LocalVarUri.replace('{version}', $Version)
                $LocalVarPathParameters['version'] = $Version
                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    $addTransformationInput = Format-PathParams -OperationTranslateSchema $translationSchema -PathParams $LocalVarPathParameters
                    Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                }
                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    $addTransformationInput = Format-Headers -OperationTranslateSchema $translationSchema -Headers $LocalVarHeaderParameters
                    Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                }
                if (
                    $useDeprecatedApis -and
                    ($null -ne $translationSchema) -and
                    ($LocalVarQueryParameters.Count -gt 0)
                ) {
                    $inputQuerySctructure = [PSCustomObject]$LocalVarQueryParameters
                    $translatedBody = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $inputQuerySctructure -InputType Body
                    $translatedQuery = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $inputQuerySctructure -InputType Query

                    if ($null -ne $translatedBody) {
                        $LocalVarBodyParameter = $translatedBody | ConvertTo-Json -Depth 100

                        if ($LocalVarContentTypes.Count -eq 0) {
                            $LocalVarContentTypes = @('application/json')
                        }
                    }
                    $LocalVarQueryParameters = @{}
                    $translatedQuery.PSObject.Properties | Foreach-Object { $LocalVarQueryParameters[$_.Name] = $_.Value }
                }

                if (!$UpdatePendingValidateRequestBody) {
                    throw "Error! The required parameter `UpdatePendingValidateRequestBody` missing when calling validateVersionPending."
                }

                if ($useDeprecatedApis -and ($null -ne $translationSchema)) {
                    if ( $UpdatePendingValidateRequestBody -is [PSCustomObject]) {
                        $addTransformationInput = Format-Body -OperationTranslateSchema $translationSchema -Body ([ref]$UpdatePendingValidateRequestBody)
                        Join-InputTransformationStructure -Base ([ref]$transformedOpertaionInput) -Addition $addTransformationInput
                    }

                    $tranlatedBody = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $UpdatePendingValidateRequestBody -InputType Body
                    $translatedQuery = Convert-InputStructure -OperationTranslateSchema $translationSchema -OperationInputObject $UpdatePendingValidateRequestBody -InputType Query
                    if ($null -ne $translatedQuery) {
                        $LocalVarQueryParameters = @{}
                        $translatedQuery.PSObject.Properties | Foreach-Object { $LocalVarQueryParameters[$_.Name] = $_.Value }
                    }
                    $UpdatePendingValidateRequestBody = $tranlatedBody

                    if ($null -ne $transformedOpertaionInput.Path) {
                        foreach ($keyValue in $transformedOpertaionInput.Path.GetEnumerator()) {
                            $LocalVarUri = $LocalVarUri.replace("{$($keyValue.Key)}", $keyValue.Value)
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Query) {
                        foreach ($keyValue in $transformedOpertaionInput.Query.GetEnumerator()) {
                            $LocalVarQueryParameters[$($keyValue.Key)] = $keyValue.Value
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Header) {
                        foreach ($keyValue in $transformedOpertaionInput.Header.GetEnumerator()) {
                            $LocalVarHeaderParameters[$($keyValue.Key)] = $keyValue.Value
                        }
                    }

                    if ($null -ne $transformedOpertaionInput.Body) {
                        if ($null -ne $UpdatePendingValidateRequestBody) {
                            foreach ($keyValue in $transformedOpertaionInput.Body.GetEnumerator()) {
                                $UpdatePendingValidateRequestBody | Add-Member -MemberType NoteProperty -Name $keyValue.Key -Value $keyValue.Value
                            }
                        } else {
                            $UpdatePendingValidateRequestBody = [PSCustomObject]$($transformedOpertaionInput.Body)
                        }
                    }
                }

                if ($null -ne $UpdatePendingValidateRequestBody) {
                    $LocalVarBodyParameter = $UpdatePendingValidateRequestBody | ConvertTo-Json -Depth 100
                }

                $invokeParams = @{
                    'Method' = $LocalVarMethod
                    'Uri' = $LocalVarUri
                    'Accepts' = $LocalVarAccepts
                    'ContentTypes' = $LocalVarContentTypes
                    'Body' = $LocalVarBodyParameter
                    'HeaderParameters' = $LocalVarHeaderParameters
                    'QueryParameters' = $LocalVarQueryParameters
                    'FormParameters' = $LocalVarFormParameters
                    'CookieParameters' = $LocalVarCookieParameters
                    'ReturnType' = "Notifications"
                    'IsBodyNullable' = $false
                    'Server' = $serverConfiguration
                }

                if ($PSBoundParameters.ContainsKey('Debug')) {
                    $invokeParams['Debug'] = $Debug
                }

                if ($PSBoundParameters.ContainsKey('Verbose')) {
                    $invokeParams['Verbose'] = $Verbose
                }

                if ($PSBoundParameters.ContainsKey('WarningAction')) {
                    $invokeParams['WarningAction'] = $PSBoundParameters.WarningAction
                }

                if ($PSBoundParameters.ContainsKey('ErrorAction')) {
                    $invokeParams['ErrorAction'] = $PSBoundParameters.ErrorAction
                }

                $invokeParams['InvocationInfo'] = @{
                    'ModuleName' = $MyInvocation.MyCommand.ModuleName
                    'CmdletName' = $MyInvocation.MyCommand.Name
                }

                $invokeResult = Invoke-vSphereApiClient @invokeParams

                $invokeResult | Foreach-Object {
                    $SingleServerResult = $_
                    if ($SingleServerResult -is [hashtable]) {

                        if ($useDeprecatedApis -and ($null -ne $translationSchema) -and ($null -ne $SingleServerResult["Response"])) {
                            $ServerName = $SingleServerResult["Response"].PSObject.TypeNames | Where-Object -FilterScript { $_.StartsWith('Server:') }

                            $SingleServerResult["Response"] = Convert-OutputBody `
                                -OperationTranslateSchema $translationSchema `
                                -OperationOutputObject $SingleServerResult["Response"]

                            if (![string]::IsNullOrEmpty($ServerName)) {
                                $SingleServerResult["Response"] | ForEach-Object -Process {
                                    $_.PSObject.TypeNames.Add($ServerName)

                                    $_ = $_ | Add-Member -MemberType ScriptMethod -Name GetServer -Value {
                                        $productServerString = ($this.PSObject.TypeNames | Where-Object -FilterScript { $_.StartsWith('Server:') }).Substring(7)
                                        $productSeparatorIndex = $productServerString.IndexOf(':')

                                        $product = $productServerString.Substring(0, $productSeparatorIndex)
                                        $server = $productServerString.Substring($productSeparatorIndex + 1, $productServerString.Length - $productSeparatorIndex - 1)

                                        Get-ServerConfiguration -Product $product | Where-Object -FilterScript { $_.ToString() -eq $server }
                                    } -Force -PassThru

                                    $_.PSObject.TypeNames.Add("ServerObject")
                                }
                            }
                        }

                        $SingleServerResult["Response"].PSObject.TypeNames.Insert(0, "Notifications")

                        if ($WithHttpInfo.IsPresent) {
                            # result object
                            $SingleServerResult
                        } else {
                            # result object
                            $SingleServerResult["Response"]
                        }

                    } else {
                        Write-Warning "An item from the Invoke-vSphereApiClient was expected to be a Hashtable but it is '$($SingleServerResult.GetType())'"
                    }
                }
            }
        }
    }
}


# SIG # Begin signature block
# MIIrHQYJKoZIhvcNAQcCoIIrDjCCKwoCAQExDzANBglghkgBZQMEAgEFADB5Bgor
# BgEEAYI3AgEEoGswaTA0BgorBgEEAYI3AgEeMCYCAwEAAAQQH8w7YFlLCE63JNLG
# KX7zUQIBAAIBAAIBAAIBAAIBADAxMA0GCWCGSAFlAwQCAQUABCCw9Qi74c7+x2Rm
# nEzqh9ntfZ6erRHhfbW2PtLeX7CeEaCCDdowggawMIIEmKADAgECAhAIrUCyYNKc
# TJ9ezam9k67ZMA0GCSqGSIb3DQEBDAUAMGIxCzAJBgNVBAYTAlVTMRUwEwYDVQQK
# EwxEaWdpQ2VydCBJbmMxGTAXBgNVBAsTEHd3dy5kaWdpY2VydC5jb20xITAfBgNV
# BAMTGERpZ2lDZXJ0IFRydXN0ZWQgUm9vdCBHNDAeFw0yMTA0MjkwMDAwMDBaFw0z
# NjA0MjgyMzU5NTlaMGkxCzAJBgNVBAYTAlVTMRcwFQYDVQQKEw5EaWdpQ2VydCwg
# SW5jLjFBMD8GA1UEAxM4RGlnaUNlcnQgVHJ1c3RlZCBHNCBDb2RlIFNpZ25pbmcg
# UlNBNDA5NiBTSEEzODQgMjAyMSBDQTEwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAw
# ggIKAoICAQDVtC9C0CiteLdd1TlZG7GIQvUzjOs9gZdwxbvEhSYwn6SOaNhc9es0
# JAfhS0/TeEP0F9ce2vnS1WcaUk8OoVf8iJnBkcyBAz5NcCRks43iCH00fUyAVxJr
# Q5qZ8sU7H/Lvy0daE6ZMswEgJfMQ04uy+wjwiuCdCcBlp/qYgEk1hz1RGeiQIXhF
# LqGfLOEYwhrMxe6TSXBCMo/7xuoc82VokaJNTIIRSFJo3hC9FFdd6BgTZcV/sk+F
# LEikVoQ11vkunKoAFdE3/hoGlMJ8yOobMubKwvSnowMOdKWvObarYBLj6Na59zHh
# 3K3kGKDYwSNHR7OhD26jq22YBoMbt2pnLdK9RBqSEIGPsDsJ18ebMlrC/2pgVItJ
# wZPt4bRc4G/rJvmM1bL5OBDm6s6R9b7T+2+TYTRcvJNFKIM2KmYoX7BzzosmJQay
# g9Rc9hUZTO1i4F4z8ujo7AqnsAMrkbI2eb73rQgedaZlzLvjSFDzd5Ea/ttQokbI
# YViY9XwCFjyDKK05huzUtw1T0PhH5nUwjewwk3YUpltLXXRhTT8SkXbev1jLchAp
# QfDVxW0mdmgRQRNYmtwmKwH0iU1Z23jPgUo+QEdfyYFQc4UQIyFZYIpkVMHMIRro
# OBl8ZhzNeDhFMJlP/2NPTLuqDQhTQXxYPUez+rbsjDIJAsxsPAxWEQIDAQABo4IB
# WTCCAVUwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQUaDfg67Y7+F8Rhvv+
# YXsIiGX0TkIwHwYDVR0jBBgwFoAU7NfjgtJxXWRM3y5nP+e6mK4cD08wDgYDVR0P
# AQH/BAQDAgGGMBMGA1UdJQQMMAoGCCsGAQUFBwMDMHcGCCsGAQUFBwEBBGswaTAk
# BggrBgEFBQcwAYYYaHR0cDovL29jc3AuZGlnaWNlcnQuY29tMEEGCCsGAQUFBzAC
# hjVodHRwOi8vY2FjZXJ0cy5kaWdpY2VydC5jb20vRGlnaUNlcnRUcnVzdGVkUm9v
# dEc0LmNydDBDBgNVHR8EPDA6MDigNqA0hjJodHRwOi8vY3JsMy5kaWdpY2VydC5j
# b20vRGlnaUNlcnRUcnVzdGVkUm9vdEc0LmNybDAcBgNVHSAEFTATMAcGBWeBDAED
# MAgGBmeBDAEEATANBgkqhkiG9w0BAQwFAAOCAgEAOiNEPY0Idu6PvDqZ01bgAhql
# +Eg08yy25nRm95RysQDKr2wwJxMSnpBEn0v9nqN8JtU3vDpdSG2V1T9J9Ce7FoFF
# UP2cvbaF4HZ+N3HLIvdaqpDP9ZNq4+sg0dVQeYiaiorBtr2hSBh+3NiAGhEZGM1h
# mYFW9snjdufE5BtfQ/g+lP92OT2e1JnPSt0o618moZVYSNUa/tcnP/2Q0XaG3Ryw
# YFzzDaju4ImhvTnhOE7abrs2nfvlIVNaw8rpavGiPttDuDPITzgUkpn13c5Ubdld
# AhQfQDN8A+KVssIhdXNSy0bYxDQcoqVLjc1vdjcshT8azibpGL6QB7BDf5WIIIJw
# 8MzK7/0pNVwfiThV9zeKiwmhywvpMRr/LhlcOXHhvpynCgbWJme3kuZOX956rEnP
# LqR0kq3bPKSchh/jwVYbKyP/j7XqiHtwa+aguv06P0WmxOgWkVKLQcBIhEuWTatE
# QOON8BUozu3xGFYHKi8QxAwIZDwzj64ojDzLj4gLDb879M4ee47vtevLt/B3E+bn
# KD+sEq6lLyJsQfmCXBVmzGwOysWGw/YmMwwHS6DTBwJqakAwSEs0qFEgu60bhQji
# WQ1tygVQK+pKHJ6l/aCnHwZ05/LWUpD9r4VIIflXO7ScA+2GRfS0YW6/aOImYIbq
# yK+p/pQd52MbOoZWeE4wggciMIIFCqADAgECAhAOxvKydqFGoH0ObZNXteEIMA0G
# CSqGSIb3DQEBCwUAMGkxCzAJBgNVBAYTAlVTMRcwFQYDVQQKEw5EaWdpQ2VydCwg
# SW5jLjFBMD8GA1UEAxM4RGlnaUNlcnQgVHJ1c3RlZCBHNCBDb2RlIFNpZ25pbmcg
# UlNBNDA5NiBTSEEzODQgMjAyMSBDQTEwHhcNMjEwODEwMDAwMDAwWhcNMjMwODEw
# MjM1OTU5WjCBhzELMAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExEjAQ
# BgNVBAcTCVBhbG8gQWx0bzEVMBMGA1UEChMMVk13YXJlLCBJbmMuMRUwEwYDVQQD
# EwxWTXdhcmUsIEluYy4xITAfBgkqhkiG9w0BCQEWEm5vcmVwbHlAdm13YXJlLmNv
# bTCCAaIwDQYJKoZIhvcNAQEBBQADggGPADCCAYoCggGBAMD6lJG8OWkM12huIQpO
# /q9JnhhhW5UyW9if3/UnoFY3oqmp0JYX/ZrXogUHYXmbt2gk01zz2P5Z89mM4gqR
# bGYC2tx+Lez4GxVkyslVPI3PXYcYSaRp39JsF3yYifnp9R+ON8O3Gf5/4EaFmbeT
# ElDCFBfExPMqtSvPZDqekodzX+4SK1PIZxCyR3gml8R3/wzhb6Li0mG7l0evQUD0
# FQAbKJMlBk863apeX4ALFZtrnCpnMlOjRb85LsjV5Ku4OhxQi1jlf8wR+za9C3DU
# ki60/yiWPu+XXwEUqGInIihECBbp7hfFWrnCCaOgahsVpgz8kKg/XN4OFq7rbh4q
# 5IkTauqFhHaE7HKM5bbIBkZ+YJs2SYvu7aHjw4Z8aRjaIbXhI1G+NtaNY7kSRrE4
# fAyC2X2zV5i4a0AuAMM40C1Wm3gTaNtRTHnka/pbynUlFjP+KqAZhOniJg4AUfjX
# sG+PG1LH2+w/sfDl1A8liXSZU1qJtUs3wBQFoSGEaGBeDQIDAQABo4ICJTCCAiEw
# HwYDVR0jBBgwFoAUaDfg67Y7+F8Rhvv+YXsIiGX0TkIwHQYDVR0OBBYEFIhC+HL9
# QlvsWsztP/I5wYwdfCFNMB0GA1UdEQQWMBSBEm5vcmVwbHlAdm13YXJlLmNvbTAO
# BgNVHQ8BAf8EBAMCB4AwEwYDVR0lBAwwCgYIKwYBBQUHAwMwgbUGA1UdHwSBrTCB
# qjBToFGgT4ZNaHR0cDovL2NybDMuZGlnaWNlcnQuY29tL0RpZ2lDZXJ0VHJ1c3Rl
# ZEc0Q29kZVNpZ25pbmdSU0E0MDk2U0hBMzg0MjAyMUNBMS5jcmwwU6BRoE+GTWh0
# dHA6Ly9jcmw0LmRpZ2ljZXJ0LmNvbS9EaWdpQ2VydFRydXN0ZWRHNENvZGVTaWdu
# aW5nUlNBNDA5NlNIQTM4NDIwMjFDQTEuY3JsMD4GA1UdIAQ3MDUwMwYGZ4EMAQQB
# MCkwJwYIKwYBBQUHAgEWG2h0dHA6Ly93d3cuZGlnaWNlcnQuY29tL0NQUzCBlAYI
# KwYBBQUHAQEEgYcwgYQwJAYIKwYBBQUHMAGGGGh0dHA6Ly9vY3NwLmRpZ2ljZXJ0
# LmNvbTBcBggrBgEFBQcwAoZQaHR0cDovL2NhY2VydHMuZGlnaWNlcnQuY29tL0Rp
# Z2lDZXJ0VHJ1c3RlZEc0Q29kZVNpZ25pbmdSU0E0MDk2U0hBMzg0MjAyMUNBMS5j
# cnQwDAYDVR0TAQH/BAIwADANBgkqhkiG9w0BAQsFAAOCAgEACQAYaQI6Nt2KgxdN
# 6qqfcHB33EZRSXkvs8O9iPZkdDjEx+2fgbBPLUvk9A7T8mRw7brbcJv4PLTYJDFo
# c5mlcmG7/5zwTOuIs2nBGXc/uxCnyW8p7kD4Y0JxPKEVQoIQ8lJS9Uy/hBjyakeV
# ef982JyzvDbOlLBy6AS3ZpXVkRY5y3Va+3v0R/0xJ+JRxUicQhiZRidq2TCiWEas
# d+tLL6jrKaBO+rmP52IM4eS9d4Yids7ogKEBAlJi0NbvuKO0CkgOlFjp1tOvD4sQ
# taHIMmqi40p4Tjyf/sY6yGjROXbMeeF1vlwbBAASPWpQuEIxrNHoVN30YfJyuOWj
# zdiJUTpeLn9XdjM3UlhfaHP+oIAKcmkd33c40SFRlQG9+P9Wlm7TcPxGU4wzXI8n
# Cw/h235jFlAAiWq9L2r7Un7YduqsheJVpGoXmRXJH0T2G2eNFS5/+2sLn98kN2Cn
# J7j6C242onjkZuGL2/+gqx8m5Jbpu9P4IAeTC1He/mX9j6XpIu+7uBoRVwuWD1i0
# N5SiUz7Lfnbr6Q1tHMXKDLFdwVKZos2AKEZhv4SU0WvenMJKDgkkhVeHPHbTahQf
# P1MetR8tdRs7uyTWAjPK5xf5DLEkXbMrUkpJ089fPvAGVHBcHRMqFA5egexOb6sj
# tKncUjJ1xAAtAExGdCh6VD2U5iYxghyZMIIclQIBATB9MGkxCzAJBgNVBAYTAlVT
# MRcwFQYDVQQKEw5EaWdpQ2VydCwgSW5jLjFBMD8GA1UEAxM4RGlnaUNlcnQgVHJ1
# c3RlZCBHNCBDb2RlIFNpZ25pbmcgUlNBNDA5NiBTSEEzODQgMjAyMSBDQTECEA7G
# 8rJ2oUagfQ5tk1e14QgwDQYJYIZIAWUDBAIBBQCggZYwGQYJKoZIhvcNAQkDMQwG
# CisGAQQBgjcCAQQwHAYKKwYBBAGCNwIBCzEOMAwGCisGAQQBgjcCARUwKgYKKwYB
# BAGCNwIBDDEcMBqhGIAWaHR0cDovL3d3dy52bXdhcmUuY29tLzAvBgkqhkiG9w0B
# CQQxIgQg4fCf3j0tBGFP9ksWOY6FuN2XTirvqEn0DGnxw/8NziQwDQYJKoZIhvcN
# AQEBBQAEggGAsxIngfaOLAuuU3pMQsunYOIEPYxx11t1P7385tXIbiCzwovriVpn
# sqZ94N4emm384SAcUqREOjuSdy0cd+FczOzV9KULfK2FSa2Wmq+wMCXC7U8+4/T9
# EEyECVAD75NZ8Eq/+puxQ6jsXzELpZDEidZ7t05mB2VJExYtRPppOHxOGmRVjanW
# n+EHi+Y9A/FlUE8voczQxz/BI62+SuY5lDcHD7F65jLfDaQrgicbh/1qXm7J+K+v
# sUfU8UuqZ8vV8Hkt0mVtolYNEDdp5PaqYFmuBryK1LymOgFm1LSoZNmjBsoyFVCg
# Y95UE7kU4qvVS2RY3/8w7PMcgYosFRKoIb3K+y3M9AfZWfFTp8JYzht0ebW47wzW
# tdaTXP6fGo8PhoXc7nJovJrc3+NVyZ4GviZkxqOEkHo0tRI4K6X7+KQEZwRKMpDJ
# Niglajuny8Ue0OcVBqg7NxKVmJv/tpkcJiGT+tmidmHsASAFFgnSaS6Uhsf90Ht9
# ZtH54BcpOtL5oYIZ1DCCGdAGCisGAQQBgjcDAwExghnAMIIZvAYJKoZIhvcNAQcC
# oIIZrTCCGakCAQMxDTALBglghkgBZQMEAgEwgdwGCyqGSIb3DQEJEAEEoIHMBIHJ
# MIHGAgEBBgkrBgEEAaAyAgMwMTANBglghkgBZQMEAgEFAAQguFkHRRM8b2SVH0Gh
# bKNfDNUnfSoSWMUBXc93ojFck3UCFEJFH5A0Lg1HQvi/9H0Kl3RzZmjHGA8yMDIz
# MDQxODE0MzkxMVowAwIBAaBXpFUwUzELMAkGA1UEBhMCQkUxGTAXBgNVBAoMEEds
# b2JhbFNpZ24gbnYtc2ExKTAnBgNVBAMMIEdsb2JhbHNpZ24gVFNBIGZvciBBZHZh
# bmNlZCAtIEc0oIIVZzCCBlgwggRAoAMCAQICEAHCnHr0eqYCWA6vMrEjsR0wDQYJ
# KoZIhvcNAQELBQAwWzELMAkGA1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24g
# bnYtc2ExMTAvBgNVBAMTKEdsb2JhbFNpZ24gVGltZXN0YW1waW5nIENBIC0gU0hB
# Mzg0IC0gRzQwHhcNMjIwNDA2MDc0NDEyWhcNMzMwNTA4MDc0NDEyWjBTMQswCQYD
# VQQGEwJCRTEZMBcGA1UECgwQR2xvYmFsU2lnbiBudi1zYTEpMCcGA1UEAwwgR2xv
# YmFsc2lnbiBUU0EgZm9yIEFkdmFuY2VkIC0gRzQwggGiMA0GCSqGSIb3DQEBAQUA
# A4IBjwAwggGKAoIBgQCj3qYhEhYSvCjgBPez1LDTAWiPU7YYWFtxoF7Y1kxz4Ffw
# uQwH94e5KYP+8NV1oUj/PbAcQLyCVWhIOgxG6z/DLJg0z8SYm3AbhhGNXhV8oQ3a
# 1nd9r+x+nBTspb8pauuKKRr+Dp8suhZNWFpjcQzbLrRwCudGEELue0V8/mRFlK/g
# 61CyUmcfcUM38eIYg0AQV5oV1/Lya56byVbbZ4MYePdlpAXM5hOFFP5fiWcBYfva
# xoMo1o1O3TQsGAMBhEjdFngl4dZIaa1cNZYhHqDDTxMAF8vCXtySTQRiyXj13qex
# hAqedDqC3ICUtwFtq6g5nhpdwXwBBl2Qez5dSijKKRCxs1nPAbghMMfZtfSXLDau
# UsezMiNug6b51CT3VvhhdXRO8garIoTI/WTlXxWl3Cd0qtLQ6bRIeNeYzLsf+NZG
# w3V1+p5FxpV1awcHqETdVnYozkpNAnlrT5Hi/Kyd67yKr3prbGQ0RvHMeBy8J/R1
# aKczyToXfopORD6D870CAwEAAaOCAZ4wggGaMA4GA1UdDwEB/wQEAwIHgDAWBgNV
# HSUBAf8EDDAKBggrBgEFBQcDCDAdBgNVHQ4EFgQUSTtntVeimeZ0GXoMWSw+COog
# e4swTAYDVR0gBEUwQzBBBgkrBgEEAaAyAR4wNDAyBggrBgEFBQcCARYmaHR0cHM6
# Ly93d3cuZ2xvYmFsc2lnbi5jb20vcmVwb3NpdG9yeS8wDAYDVR0TAQH/BAIwADCB
# kAYIKwYBBQUHAQEEgYMwgYAwOQYIKwYBBQUHMAGGLWh0dHA6Ly9vY3NwLmdsb2Jh
# bHNpZ24uY29tL2NhL2dzdHNhY2FzaGEzODRnNDBDBggrBgEFBQcwAoY3aHR0cDov
# L3NlY3VyZS5nbG9iYWxzaWduLmNvbS9jYWNlcnQvZ3N0c2FjYXNoYTM4NGc0LmNy
# dDAfBgNVHSMEGDAWgBTqFsZp5+PLV0U5M6TwQL7Qw71lljBBBgNVHR8EOjA4MDag
# NKAyhjBodHRwOi8vY3JsLmdsb2JhbHNpZ24uY29tL2NhL2dzdHNhY2FzaGEzODRn
# NC5jcmwwDQYJKoZIhvcNAQELBQADggIBAAiIpOqFiDNYa378AFUi029DaW98/r5D
# hjcOn1PaUZ7QPOMbmddRURkPUZAO2+6aRs99CuDG7BWC6z6uzAP6We2PpUqiGT7C
# X/0WgzFWUihLX8RFg2HrlgwgMKJ9ReqWbbL8dLj9TGGUaqew6qm/OI6YdnUHpvul
# 3AtvdXpk6TDXkZBi0OHLGeToLyeIQIyH2z/bFbBIjeKNlYwn86xJh7B86cSl4Nnc
# vvYNFbjeY519liutpK6UYDfQSJmo270vTvQAj7f8SNq2EEDEPznbVXe9CzysNqBK
# mRTg0DEeidInCnBQ3a1vZPpvjRr2UPQWEzAMGM7YaELVVeNaX8CggbwZvESwY4p+
# wCseVW7nHR4TZJlmZAmD6YHmPiv95HzsQ7ubbzVik2Sau1i4rwRuKLsKWOOFOSXU
# 44sVcwE6HctdkfyeRS6HtfBGnJTDaK36DutH2akl1ooK2J7vrKJepi6cWNG9Ub8S
# ctARm0zPm1K/p+pKlCL82nSzRdSzCdZoREAqH4ps2uVpcQAS+Mnf6pipKmqP1Jrg
# H6yZ4ehdPnk8RaQOCoYUoBXlkiCB8oKO86rJnF8cSXT8IbUo4IEN/7d/mIPAYNMB
# xWbMYbzCpAsDNzaaMiXCxeaDlPzQeb+D07xTteP+z+FxPgXbYo8kve9TqvKeUww/
# fGvw6iU4X3KqMIIGWTCCBEGgAwIBAgINAewckkDe/S5AXXxHdDANBgkqhkiG9w0B
# AQwFADBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSNjETMBEGA1UE
# ChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjAeFw0xODA2MjAwMDAw
# MDBaFw0zNDEyMTAwMDAwMDBaMFsxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9i
# YWxTaWduIG52LXNhMTEwLwYDVQQDEyhHbG9iYWxTaWduIFRpbWVzdGFtcGluZyBD
# QSAtIFNIQTM4NCAtIEc0MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA
# 8ALiMCP64BvhmnSzr3WDX6lHUsdhOmN8OSN5bXT8MeR0EhmW+s4nYluuB4on7lej
# xDXtszTHrMMM64BmbdEoSsEsu7lw8nKujPeZWl12rr9EqHxBJI6PusVP/zZBq6ct
# /XhOQ4j+kxkX2e4xz7yKO25qxIjw7pf23PMYoEuZHA6HpybhiMmg5ZninvScTD9d
# W+y279Jlz0ULVD2xVFMHi5luuFSZiqgxkjvyen38DljfgWrhsGweZYIq1CHHlP5C
# ljvxC7F/f0aYDoc9emXr0VapLr37WD21hfpTmU1bdO1yS6INgjcZDNCr6lrB7w/V
# mbk/9E818ZwP0zcTUtklNO2W7/hn6gi+j0l6/5Cx1PcpFdf5DV3Wh0MedMRwKLSA
# e70qm7uE4Q6sbw25tfZtVv6KHQk+JA5nJsf8sg2glLCylMx75mf+pliy1NhBEsFV
# /W6RxbuxTAhLntRCBm8bGNU26mSuzv31BebiZtAOBSGssREGIxnk+wU0ROoIrp1J
# ZxGLguWtWoanZv0zAwHemSX5cW7pnF0CTGA8zwKPAf1y7pLxpxLeQhJN7Kkm5XcC
# rA5XDAnRYZ4miPzIsk3bZPBFn7rBP1Sj2HYClWxqjcoiXPYMBOMp+kuwHNM3dITZ
# HWarNHOPHn18XpbWPRmwl+qMUJFtr1eGfhA3HWsaFN8CAwEAAaOCASkwggElMA4G
# A1UdDwEB/wQEAwIBhjASBgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBTqFsZp
# 5+PLV0U5M6TwQL7Qw71lljAfBgNVHSMEGDAWgBSubAWjkxPioufi1xzWx/B/yGdT
# oDA+BggrBgEFBQcBAQQyMDAwLgYIKwYBBQUHMAGGImh0dHA6Ly9vY3NwMi5nbG9i
# YWxzaWduLmNvbS9yb290cjYwNgYDVR0fBC8wLTAroCmgJ4YlaHR0cDovL2NybC5n
# bG9iYWxzaWduLmNvbS9yb290LXI2LmNybDBHBgNVHSAEQDA+MDwGBFUdIAAwNDAy
# BggrBgEFBQcCARYmaHR0cHM6Ly93d3cuZ2xvYmFsc2lnbi5jb20vcmVwb3NpdG9y
# eS8wDQYJKoZIhvcNAQEMBQADggIBAH/iiNlXZytCX4GnCQu6xLsoGFbWTL/bGwdw
# xvsLCa0AOmAzHznGFmsZQEklCB7km/fWpA2PHpbyhqIX3kG/T+G8q83uwCOMxoX+
# SxUk+RhE7B/CpKzQss/swlZlHb1/9t6CyLefYdO1RkiYlwJnehaVSttixtCzAsw0
# SEVV3ezpSp9eFO1yEHF2cNIPlvPqN1eUkRiv3I2ZOBlYwqmhfqJuFSbqtPl/Kufn
# SGRpL9KaoXL29yRLdFp9coY1swJXH4uc/LusTN763lNMg/0SsbZJVU91naxvSsgu
# arnKiMMSME6yCHOfXqHWmc7pfUuWLMwWaxjN5Fk3hgks4kXWss1ugnWl2o0et1sv
# iC49ffHykTAFnM57fKDFrK9RBvARxx0wxVFWYOh8lT0i49UKJFMnl4D6SIknLHni
# POWbHuOqhIKJPsBK9SH+YhDtHTD89szqSCd8i3VCf2vL86VrlR8EWDQKie2CUOTR
# e6jJ5r5IqitV2Y23JSAOG1Gg1GOqg+pscmFKyfpDxMZXxZ22PLCLsLkcMe+97xTY
# FEBsIB3CLegLxo1tjLZx7VIh/j72n585Gq6s0i96ILH0rKod4i0UnfqWah3GPMrz
# 2Ry/U02kR1l8lcRDQfkl4iwQfoH5DZSnffK1CfXYYHJAUJUg1ENEvvqglecgWbZ4
# xqRqqiKbMIIFRzCCBC+gAwIBAgINAfJAQkDO/SLb6Wxx/DANBgkqhkiG9w0BAQwF
# ADBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEGA1UEChMK
# R2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjAeFw0xOTAyMjAwMDAwMDBa
# Fw0yOTAzMTgxMDAwMDBaMEwxIDAeBgNVBAsTF0dsb2JhbFNpZ24gUm9vdCBDQSAt
# IFI2MRMwEQYDVQQKEwpHbG9iYWxTaWduMRMwEQYDVQQDEwpHbG9iYWxTaWduMIIC
# IjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAlQfoc8pm+ewUyns89w0I8bRF
# CyyCtEjG61s8roO4QZIzFKRvf+kqzMawiGvFtonRxrL/FM5RFCHsSt0bWsbWh+5N
# OhUG7WRmC5KAykTec5RO86eJf094YwjIElBtQmYvTbl5KE1SGooagLcZgQ5+xIq8
# ZEwhHENo1z08isWyZtWQmrcxBsW+4m0yBqYe+bnrqqO4v76CY1DQ8BiJ3+QPefXq
# oh8q0nAue+e8k7ttU+JIfIwQBzj/ZrJ3YX7g6ow8qrSk9vOVShIHbf2MsonP0KBh
# d8hYdLDUIzr3XTrKotudCd5dRC2Q8YHNV5L6frxQBGM032uTGL5rNrI55KwkNrfw
# 77YcE1eTtt6y+OKFt3OiuDWqRfLgnTahb1SK8XJWbi6IxVFCRBWU7qPFOJabTk5a
# C0fzBjZJdzC8cTflpuwhCHX85mEWP3fV2ZGXhAps1AJNdMAU7f05+4PyXhShBLAL
# 6f7uj+FuC7IIs2FmCWqxBjplllnA8DX9ydoojRoRh3CBCqiadR2eOoYFAJ7bgNYl
# +dwFnidZTHY5W+r5paHYgw/R/98wEfmFzzNI9cptZBQselhP00sIScWVZBpjDnk9
# 9bOMylitnEJFeW4OhxlcVLFltr+Mm9wT6Q1vuC7cZ27JixG1hBSKABlwg3mRl5HU
# Gie/Nx4yB9gUYzwoTK8CAwEAAaOCASYwggEiMA4GA1UdDwEB/wQEAwIBBjAPBgNV
# HRMBAf8EBTADAQH/MB0GA1UdDgQWBBSubAWjkxPioufi1xzWx/B/yGdToDAfBgNV
# HSMEGDAWgBSP8Et/qC5FJK5NUPpjmove4t0bvDA+BggrBgEFBQcBAQQyMDAwLgYI
# KwYBBQUHMAGGImh0dHA6Ly9vY3NwMi5nbG9iYWxzaWduLmNvbS9yb290cjMwNgYD
# VR0fBC8wLTAroCmgJ4YlaHR0cDovL2NybC5nbG9iYWxzaWduLmNvbS9yb290LXIz
# LmNybDBHBgNVHSAEQDA+MDwGBFUdIAAwNDAyBggrBgEFBQcCARYmaHR0cHM6Ly93
# d3cuZ2xvYmFsc2lnbi5jb20vcmVwb3NpdG9yeS8wDQYJKoZIhvcNAQEMBQADggEB
# AEmsXsWD81rLYSpNl0oVKZ/kFJCqCfnEep81GIoKMxVtcociTkE/bQqeGK7b4l/8
# ldEsmBQ7jsHwNll5842Bz3T2GKTk4WjP739lWULpylU5vNPFJu5xOPrXIQMPt07Z
# W2BqQ7R9CdBgYd2q7QBeTjIe4LJsnjyywruY05B2ammtGtyoidpYT9LCizJKzlT7
# OOk7Bwt1ChHbC3wlJ/GsJs8RU+bcxuJhNTL0zt2D4xk668Joo3IAyCQ8TrhTPLEX
# q+Y1LPnTQinmX2ADrEJhprFXajNC3zUxhso+NyvaxNok9U4S8ra5t0fquyCtYRa3
# oDPjLYmnvLM8AX8jGoAJNOkwggNfMIICR6ADAgECAgsEAAAAAAEhWFMIojANBgkq
# hkiG9w0BAQsFADBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzET
# MBEGA1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjAeFw0wOTAz
# MTgxMDAwMDBaFw0yOTAzMTgxMDAwMDBaMEwxIDAeBgNVBAsTF0dsb2JhbFNpZ24g
# Um9vdCBDQSAtIFIzMRMwEQYDVQQKEwpHbG9iYWxTaWduMRMwEQYDVQQDEwpHbG9i
# YWxTaWduMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAzCV2kHkGeCIW
# 9cCDtoTKKJ79BXYRxa2IcvxGAkPHsoqdBF8kyy5L4WCCRuFSqwyBR3Bs3WTR6/Us
# ow+CPQwrrpfXthSGEHm7OxOAd4wI4UnSamIvH176lmjfiSeVOJ8G1z7JyyZZDXPe
# sMjpJg6DFcbvW4vSBGDKSaYo9mk79svIKJHlnYphVzesdBTcdOA67nIvLpz70Lu/
# 9T0A4QYz6IIrrlOmOhZzjN1BDiA6wLSnoemyT5AuMmDpV8u5BJJoaOU4JmB1sp93
# /5EU764gSfytQBVI0QIxYRleuJfvrXe3ZJp6v1/BE++bYvsNbOBUaRapA9pu6YOT
# cXbGaYWCFwIDAQABo0IwQDAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB
# /zAdBgNVHQ4EFgQUj/BLf6guRSSuTVD6Y5qL3uLdG7wwDQYJKoZIhvcNAQELBQAD
# ggEBAEtA28BQqv7IDO/3llRFSbuWAAlBrLMThoYoBzPKa+Z0uboALa6kCtP18fEP
# ir9zZ0qDx0R7eOCvbmxvAymOMzlFw47kuVdsqvwSluxTxi3kJGy5lGP73FNoZ1Y+
# g7jPNSHDyWj+ztrCU6rMkIrp8F1GjJXdelgoGi8d3s0AN0GP7URt11Mol37zZwQe
# FdeKlrTT3kwnpEwbc3N29BeZwh96DuMtCK0KHCz/PKtVDg+Rfjbrw1dJvuEuLXxg
# i8NBURMjnc73MmuUAaiZ5ywzHzo7JdKGQM47LIZ4yWEvFLru21Vv34TuBQlNvSjY
# cs7TYlBlHuuSl4Mx2bO1ykdYP18xggNJMIIDRQIBATBvMFsxCzAJBgNVBAYTAkJF
# MRkwFwYDVQQKExBHbG9iYWxTaWduIG52LXNhMTEwLwYDVQQDEyhHbG9iYWxTaWdu
# IFRpbWVzdGFtcGluZyBDQSAtIFNIQTM4NCAtIEc0AhABwpx69HqmAlgOrzKxI7Ed
# MAsGCWCGSAFlAwQCAaCCAS0wGgYJKoZIhvcNAQkDMQ0GCyqGSIb3DQEJEAEEMCsG
# CSqGSIb3DQEJNDEeMBwwCwYJYIZIAWUDBAIBoQ0GCSqGSIb3DQEBCwUAMC8GCSqG
# SIb3DQEJBDEiBCD2jV+uLbF+f5+MJ5WazMoY5bpsuRvD3LOl4ejIDu/bWzCBsAYL
# KoZIhvcNAQkQAi8xgaAwgZ0wgZowgZcEIK+AMe1uyzkUREiVvQsdDOsSlZTbXgws
# bfa+crElQkfQMHMwX6RdMFsxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9iYWxT
# aWduIG52LXNhMTEwLwYDVQQDEyhHbG9iYWxTaWduIFRpbWVzdGFtcGluZyBDQSAt
# IFNIQTM4NCAtIEc0AhABwpx69HqmAlgOrzKxI7EdMA0GCSqGSIb3DQEBCwUABIIB
# gKKjQZovbCra1i+Wi0/Z6HkGT+p1f2siqmKJ6y/Y+93kHTAUi9V9yliQVnNhgiGD
# O5Z87o3xARZryAmlc3ObWXl8w1DfMVxVz6SJQfok9W5CsP+19iZr3CQJ/u6qAJNE
# vJbrdmfIhaiPn4pWkOPTfgIY+zIx0fR/CFPaX3fO1ZCCsUcbOfy1ox9jQUxgWahu
# ZjRH5NG3NwsrmlKcehYdSTg7CiYFXVwQM8B/fy6cnvFrt0FeqIky8r4HcmbXAtzi
# la/IH2OmpmoAgeNKTsrieVhXPwUpCuRH8F0ZbhOz+B4JHP/qvtl7NVx1kTz+WPfK
# JFNQhBhnljf5fYddw4+rQaMytFxFrHkLt4wPJ9HdCHPN7okUfLp3YZi+lU8WN6rT
# I8aRxvamqnmZ09HJwPUIpl8SEZGOI0O9l+lfdW6Ks2VGJ6tYuZhtMh0NIK0wuc1d
# nm0882FCzQB8l+Tf31ffSiVG61Os44RRfU+sxotYbGG8fcjUtoU5EtGqLuFcsj04
# jQ==
# SIG # End signature block
